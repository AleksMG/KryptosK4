<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>K4 Advanced Cryptanalysis Suite</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        :root {
            --primary: #4a6fa5;
            --secondary: #166088;
            --dark: #0a0a0a;
            --light: #f8f9fa;
            --success: #28a745;
            --warning: #ffc107;
            --danger: #dc3545;
            --info: #17a2b8;
        }
        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f5f7fa;
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            background: white;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.1);
            border-radius: 8px;
        }
        
        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            padding-bottom: 15px;
            border-bottom: 1px solid #eee;
        }
        
        .logo {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .logo i {
            color: var(--primary);
            font-size: 2rem;
        }
        
        h1, h2, h3, h4 {
            color: var(--secondary);
            margin-bottom: 15px;
        }
        
        .tabs {
            display: flex;
            margin-bottom: 20px;
            border-bottom: 1px solid #ddd;
        }
        
        .tab {
            padding: 10px 20px;
            cursor: pointer;
            border-bottom: 3px solid transparent;
            transition: all 0.3s;
        }
        
        .tab.active {
            border-bottom-color: var(--primary);
            color: var(--primary);
            font-weight: bold;
        }
        
        .tab:hover:not(.active) {
            background-color: #f0f0f0;
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .input-group {
            margin-bottom: 20px;
        }
        
        textarea, select, input {
            width: 100%;
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-family: inherit;
            font-size: 16px;
            margin-bottom: 10px;
            transition: border 0.3s;
        }
        
        textarea {
            min-height: 150px;
            resize: vertical;
        }
        
        textarea:focus, select:focus, input:focus {
            border-color: var(--primary);
            outline: none;
            box-shadow: 0 0 0 3px rgba(74, 111, 165, 0.2);
        }
        
        .btn {
            display: inline-block;
            padding: 10px 20px;
            background-color: var(--primary);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s;
        }
        
        .btn:hover {
            background-color: var(--secondary);
            transform: translateY(-2px);
        }
        
        .btn i {
            margin-right: 5px;
        }
        
        .btn-group {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }
        
        .btn-outline {
            background-color: transparent;
            border: 1px solid var(--primary);
            color: var(--primary);
        }
        
        .btn-outline:hover {
            background-color: var(--primary);
            color: white;
        }
        
        .result-container {
            margin-top: 30px;
        }
        
        .result-card {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
            padding: 20px;
            margin-bottom: 20px;
            border-left: 4px solid var(--primary);
        }
        
        .result-card h3 {
            margin-top: 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .result-card h3 .badge {
            background-color: var(--info);
            color: white;
            padding: 3px 8px;
            border-radius: 20px;
            font-size: 14px;
        }
        
        pre {
            white-space: pre-wrap;
            word-break: break-word;
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 4px;
            border: 1px solid #eee;
            font-family: 'Courier New', Courier, monospace;
            overflow-x: auto;
        }
        
        .table-responsive {
            overflow-x: auto;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 20px;
        }
        
        th, td {
            padding: 12px 15px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }
        
        th {
            background-color: #f8f9fa;
            font-weight: 600;
        }
        
        tr:hover {
            background-color: #f5f5f5;
        }
        
        .progress-container {
            width: 100%;
            background-color: #e9ecef;
            border-radius: 4px;
            margin-bottom: 20px;
            height: 20px;
        }
        
        .progress-bar {
            height: 100%;
            border-radius: 4px;
            background-color: var(--primary);
            width: 0%;
            transition: width 0.3s;
        }
        
        .chart-container {
            height: 300px;
            margin-bottom: 30px;
        }
        
        .keyboard {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin-bottom: 20px;
        }
        
        .key {
            width: 40px;
            height: 40px;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #f8f9fa;
            border: 1px solid #ddd;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .key:hover {
            background-color: #e9ecef;
        }
        
        .key.active {
            background-color: var(--primary);
            color: white;
            border-color: var(--primary);
        }
        
        .settings-panel {
            background-color: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        
        .settings-row {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-bottom: 15px;
        }
        
        .setting {
            flex: 1;
            min-width: 200px;
        }
        
        .setting label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
        }
        
        .histogram {
            display: flex;
            height: 200px;
            align-items: flex-end;
            gap: 2px;
            margin-top: 20px;
        }
        
        .histogram-bar {
            flex: 1;
            background-color: var(--primary);
            position: relative;
            transition: height 0.3s;
        }
        
        .histogram-bar:hover {
            background-color: var(--secondary);
        }
        
        .histogram-label {
            position: absolute;
            bottom: -25px;
            width: 100%;
            text-align: center;
            font-size: 12px;
        }
        
        .histogram-value {
            position: absolute;
            top: -25px;
            width: 100%;
            text-align: center;
            font-size: 12px;
        }
        
        .tooltip {
            position: relative;
            display: inline-block;
            border-bottom: 1px dotted #777;
            cursor: help;
        }
        
        .tooltip .tooltiptext {
            visibility: hidden;
            width: 200px;
            background-color: #555;
            color: #fff;
            text-align: center;
            border-radius: 6px;
            padding: 5px;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            margin-left: -100px;
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }
        
        .match-highlight {
            background-color: rgba(40, 167, 69, 0.3);
            padding: 0 2px;
            border-radius: 2px;
        }
        
        .alert {
            padding: 15px;
            border-radius: 4px;
            margin-bottom: 20px;
        }
        
        .alert-info {
            background-color: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }
        
        .alert-success {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        
        .alert-warning {
            background-color: #fff3cd;
            color: #856404;
            border: 1px solid #ffeeba;
        }
        
        .alert-danger {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0, 0, 0, 0.5);
        }
        
        .modal-content {
            background-color: #fefefe;
            margin: 10% auto;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            width: 80%;
            max-width: 800px;
            max-height: 80vh;
            overflow-y: auto;
        }
        
        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }
        
        .close:hover {
            color: black;
        }
        
        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }
            
            .tabs {
                flex-wrap: wrap;
            }
            
            .tab {
                flex: 1 0 auto;
                text-align: center;
                padding: 8px 5px;
                font-size: 14px;
            }
            
            .btn-group {
                flex-direction: column;
            }
            
            .settings-row {
                flex-direction: column;
                gap: 10px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <div class="logo">
                <i class="fas fa-lock"></i>
                <h1>K4 Advanced Cryptanalysis Suite</h1>
            </div>
            <div>
                <button class="btn btn-outline" onclick="showHelp()">
                    <i class="fas fa-question-circle"></i> Help
                </button>
                <button class="btn btn-outline" onclick="showSettings()">
                    <i class="fas fa-cog"></i> Settings
                </button>
            </div>
        </header>
        
        <div class="tabs">
            <div class="tab active" onclick="switchTab('analysis')">Full Analysis</div>
            <div class="tab" onclick="switchTab('vigenere')">Vigenère Tools</div>
            <div class="tab" onclick="switchTab('custom')">Custom Alphabet</div>
            <div class="tab" onclick="switchTab('reports')">Reports</div>
        </div>
        
        <!-- Full Analysis Tab -->
        <div id="analysis" class="tab-content active">
            <div class="alert alert-info">
                <i class="fas fa-info-circle"></i> This tool performs comprehensive cryptanalysis on ciphertext using multiple methods including Kasiski examination, Friedman test, and frequency analysis.
            </div>
            
            <div class="input-group">
                <label for="ciphertext">Ciphertext (A-Z only):</label>
                <textarea id="ciphertext" placeholder="Enter ciphertext here...">OBKRUOXOGHULBSOLIFBBWFLRVQQPRNGKSSOTWTQSJQSSEKZZWATJKLUDIAWINFBNYPVTTMZFPKWGDKZXTJCDIGKUHUAUEKCAR</textarea>
            </div>
            
            <div class="settings-panel">
                <h3><i class="fas fa-sliders-h"></i> Analysis Settings</h3>
                <div class="settings-row">
                    <div class="setting">
                        <label for="max-key-length">Max Key Length to Test:</label>
                        <input type="number" id="max-key-length" min="1" max="50" value="20">
                    </div>
                    <div class="setting">
                        <label for="target-words">Target Words (comma separated):</label>
                        <input type="text" id="target-words" value="BERLIN,CLOCK,NORTHEAST,SOUTH">
                    </div>
                </div>
                <div class="settings-row">
                    <div class="setting">
                        <label for="language-profile">Language Profile:</label>
                        <select id="language-profile">
                            <option value="english">English</option>
                            <option value="german">German</option>
                            <option value="french">French</option>
                            <option value="spanish">Spanish</option>
                            <option value="custom">Custom</option>
                        </select>
                    </div>
                    <div class="setting">
                        <label for="analysis-depth">Analysis Depth:</label>
                        <select id="analysis-depth">
                            <option value="quick">Quick (faster, less thorough)</option>
                            <option value="standard" selected>Standard</option>
                            <option value="deep">Deep (slower, more thorough)</option>
                        </select>
                    </div>
                </div>
            </div>
            
            <div class="btn-group">
                <button class="btn" onclick="startFullAnalysis()">
                    <i class="fas fa-play"></i> Start Full Analysis
                </button>
                <button class="btn btn-outline" onclick="clearResults()">
                    <i class="fas fa-trash-alt"></i> Clear Results
                </button>
                <button class="btn btn-outline" onclick="saveAnalysis()">
                    <i class="fas fa-save"></i> Save Analysis
                </button>
            </div>
            
            <div id="progress-container" class="progress-container" style="display: none;">
                <div id="progress-bar" class="progress-bar"></div>
            </div>
            
            <div id="output" class="result-container"></div>
        </div>
        
        <!-- Vigenère Tools Tab -->
        <div id="vigenere" class="tab-content">
            <div class="alert alert-info">
                <i class="fas fa-info-circle"></i> This tool provides specialized functions for working with Vigenère cipher including encryption, decryption, and key testing.
            </div>
            
            <div class="input-group">
                <label for="vigenere-text">Text:</label>
                <textarea id="vigenere-text" placeholder="Enter text here..."></textarea>
            </div>
            
            <div class="settings-row">
                <div class="setting">
                    <label for="vigenere-key">Key:</label>
                    <input type="text" id="vigenere-key" placeholder="Enter key...">
                </div>
                <div class="setting">
                    <label for="vigenere-mode">Mode:</label>
                    <select id="vigenere-mode">
                        <option value="encrypt">Encrypt</option>
                        <option value="decrypt">Decrypt</option>
                    </select>
                </div>
                <div class="setting">
                    <label for="vigenere-alphabet">Alphabet:</label>
                    <select id="vigenere-alphabet">
                        <option value="standard">Standard (A-Z)</option>
                        <option value="custom">Custom</option>
                    </select>
                </div>
            </div>
            
            <div id="custom-alphabet-container" style="display: none;">
                <label for="custom-alphabet">Custom Alphabet:</label>
                <input type="text" id="custom-alphabet" placeholder="ABCDEFGHIJKLMNOPQRSTUVWXYZ">
            </div>
            
            <div class="btn-group">
                <button class="btn" onclick="processVigenere()">
                    <i class="fas fa-cogs"></i> Process
                </button>
                <button class="btn btn-outline" onclick="testKeyVariations()">
                    <i class="fas fa-key"></i> Test Key Variations
                </button>
                <button class="btn btn-outline" onclick="findLikelyKeyLength()">
                    <i class="fas fa-ruler"></i> Find Key Length
                </button>
            </div>
            
            <div id="vigenere-output" class="result-container"></div>
        </div>
        
        <!-- Custom Alphabet Tab -->
        <div id="custom" class="tab-content">
            <div class="alert alert-info">
                <i class="fas fa-info-circle"></i> Create and manage custom alphabets for specialized cipher analysis.
            </div>
            
            <div class="input-group">
                <label for="alphabet-name">Alphabet Name:</label>
                <input type="text" id="alphabet-name" placeholder="My Custom Alphabet">
            </div>
            
            <div class="input-group">
                <label for="alphabet-chars">Characters (in order):</label>
                <textarea id="alphabet-chars" placeholder="ABCDEFGHIJKLMNOPQRSTUVWXYZ"></textarea>
            </div>
            
            <div class="input-group">
                <label>Character Frequency (optional):</label>
                <div id="frequency-editor">
                    <p>Enter frequency percentages for each character (must sum to 100%):</p>
                    <div id="frequency-inputs"></div>
                </div>
            </div>
            
            <div class="btn-group">
                <button class="btn" onclick="saveCustomAlphabet()">
                    <i class="fas fa-save"></i> Save Alphabet
                </button>
                <button class="btn btn-outline" onclick="loadCustomAlphabet()">
                    <i class="fas fa-folder-open"></i> Load Alphabet
                </button>
                <button class="btn btn-outline" onclick="testCustomAlphabet()">
                    <i class="fas fa-vial"></i> Test Alphabet
                </button>
            </div>
            
            <div id="custom-alphabet-output" class="result-container"></div>
        </div>
        
        <!-- Reports Tab -->
        <div id="reports" class="tab-content">
            <div class="alert alert-info">
                <i class="fas fa-info-circle"></i> Generate detailed reports of your analysis sessions.
            </div>
            
            <div class="btn-group">
                <button class="btn" onclick="generateFullReport()">
                    <i class="fas fa-file-alt"></i> Generate Full Report
                </button>
                <button class="btn btn-outline" onclick="exportToCSV()">
                    <i class="fas fa-file-csv"></i> Export to CSV
                </button>
                <button class="btn btn-outline" onclick="exportToJSON()">
                    <i class="fas fa-file-code"></i> Export to JSON
                </button>
            </div>
            
            <div id="report-output" class="result-container"></div>
        </div>
    </div>
    
    <!-- Help Modal -->
    <div id="helpModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeModal('helpModal')">&times;</span>
            <h2>K4 Advanced Cryptanalysis Suite Help</h2>
            <h3>Full Analysis Tab</h3>
            <p>This tab performs comprehensive cryptanalysis on your ciphertext using multiple methods:</p>
            <ul>
                <li><strong>Kasiski Examination:</strong> Estimates the likely key length by finding repeated sequences</li>
                <li><strong>Friedman Test:</strong> Calculates the index of coincidence to help determine if the text is likely to be encrypted with a polyalphabetic cipher</li>
                <li><strong>Frequency Analysis:</strong> Shows character distribution compared to expected language frequencies</li>
                <li><strong>Key Testing:</strong> Tests various keys and scores the decrypted text based on language patterns and target words</li>
            </ul>
            
            <h3>Vigenère Tools Tab</h3>
            <p>Specialized tools for working with the Vigenère cipher:</p>
            <ul>
                <li><strong>Encrypt/Decrypt:</strong> Process text with a given key</li>
                <li><strong>Key Testing:</strong> Test variations of a key to find the most likely decryption</li>
                <li><strong>Key Length Finder:</strong> Estimate the key length using statistical methods</li>
            </ul>
            
            <h3>Custom Alphabet Tab</h3>
            <p>Create and manage custom alphabets for specialized cipher analysis.</p>
            
            <h3>Reports Tab</h3>
            <p>Generate detailed reports of your analysis sessions in various formats.</p>
        </div>
    </div>
    
    <!-- Settings Modal -->
    <div id="settingsModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeModal('settingsModal')">&times;</span>
            <h2>Application Settings</h2>
            
            <div class="settings-panel">
                <h3><i class="fas fa-chart-bar"></i> Analysis Settings</h3>
                <div class="setting">
                    <label for="max-results">Maximum Results to Display:</label>
                    <input type="number" id="max-results" min="5" max="100" value="10">
                </div>
                <div class="setting">
                    <label for="auto-save">Auto-save Analysis:</label>
                    <select id="auto-save">
                        <option value="true">Enabled</option>
                        <option value="false">Disabled</option>
                    </select>
                </div>
            </div>
            
            <div class="settings-panel">
                <h3><i class="fas fa-paint-brush"></i> UI Settings</h3>
                <div class="setting">
                    <label for="theme">Color Theme:</label>
                    <select id="theme">
                        <option value="light">Light</option>
                        <option value="dark">Dark</option>
                        <option value="blue">Blue</option>
                        <option value="high-contrast">High Contrast</option>
                    </select>
                </div>
                <div class="setting">
                    <label for="font-size">Font Size:</label>
                    <select id="font-size">
                        <option value="small">Small</option>
                        <option value="medium" selected>Medium</option>
                        <option value="large">Large</option>
                    </select>
                </div>
            </div>
            
            <button class="btn" onclick="saveSettings()">
                <i class="fas fa-save"></i> Save Settings
            </button>
        </div>
    </div>
    
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script>
        // Global variables
        let analysisHistory = [];
        let customAlphabets = {};
        let currentAnalysis = null;
        
        // Initialize the application
        document.addEventListener('DOMContentLoaded', function() {
            // Load saved data
            loadSavedData();
            
            // Set up event listeners
            document.getElementById('vigenere-alphabet').addEventListener('change', function() {
                document.getElementById('custom-alphabet-container').style.display = 
                    this.value === 'custom' ? 'block' : 'none';
            });
            
            document.getElementById('alphabet-chars').addEventListener('input', function() {
                updateFrequencyInputs();
            });
            
            // Initialize frequency inputs
            updateFrequencyInputs();
        });
        
        // Tab switching
        function switchTab(tabId) {
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.remove('active');
            });
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
            });
            
            document.getElementById(tabId).classList.add('active');
            document.querySelector(`.tab[onclick="switchTab('${tabId}')"]`).classList.add('active');
        }
        
        // Modal functions
        function showHelp() {
            document.getElementById('helpModal').style.display = 'block';
        }
        
        function showSettings() {
            document.getElementById('settingsModal').style.display = 'block';
        }
        
        function closeModal(id) {
            document.getElementById(id).style.display = 'none';
        }
        
        // Analysis functions
        class K4Analyzer {
            constructor() {
                this.languageProfiles = {
                    english: {
                        name: "English",
                        frequencies: {
                            'E': 12.70, 'T': 9.10, 'A': 8.20, 'O': 7.50, 'I': 6.90,
                            'N': 6.70, 'S': 6.30, 'H': 6.10, 'R': 6.00, 'D': 4.30,
                            'L': 4.00, 'C': 2.80, 'U': 2.80, 'M': 2.40, 'W': 2.40,
                            'F': 2.20, 'G': 2.00, 'Y': 2.00, 'P': 1.90, 'B': 1.50,
                            'V': 0.98, 'K': 0.77, 'J': 0.15, 'X': 0.15, 'Q': 0.10,
                            'Z': 0.07
                        },
                        commonWords: ["THE", "AND", "FOR", "ARE", "BUT", "NOT", "YOU", "ALL", "ANY", "CAN"]
                    },
                    german: {
                        name: "German",
                        frequencies: {
                            'E': 16.93, 'N': 10.53, 'I': 8.02, 'S': 7.27, 'R': 6.89,
                            'A': 6.51, 'T': 5.79, 'D': 5.08, 'H': 4.76, 'U': 4.35,
                            'L': 3.44, 'C': 3.06, 'G': 3.01, 'M': 2.53, 'O': 2.51,
                            'B': 1.89, 'W': 1.78, 'F': 1.66, 'K': 1.21, 'Z': 1.13,
                            'P': 0.79, 'V': 0.67, 'J': 0.27, 'Y': 0.04, 'X': 0.03,
                            'Q': 0.02
                        },
                        commonWords: ["DER", "DIE", "UND", "IN", "DEN", "VON", "ZU", "MIT", "SICH", "DES"]
                    },
                    french: {
                        name: "French",
                        frequencies: {
                            'E': 15.10, 'A': 8.13, 'I': 7.11, 'S': 7.08, 'N': 6.94,
                            'T': 6.51, 'R': 6.16, 'U': 5.74, 'L': 5.50, 'O': 5.38,
                            'D': 3.67, 'C': 3.26, 'M': 2.96, 'P': 2.92, 'V': 1.64,
                            'Q': 1.43, 'F': 1.12, 'B': 0.96, 'G': 0.92, 'H': 0.85,
                            'J': 0.71, 'X': 0.51, 'Y': 0.46, 'Z': 0.32, 'K': 0.07,
                            'W': 0.04
                        },
                        commonWords: ["LE", "LA", "ET", "LES", "DES", "UN", "UNE", "EST", "POUR", "QUE"]
                    },
                    spanish: {
                        name: "Spanish",
                        frequencies: {
                            'E': 13.72, 'A': 12.53, 'O': 8.68, 'S': 7.98, 'R': 6.87,
                            'N': 6.71, 'I': 6.25, 'D': 5.86, 'L': 4.97, 'C': 4.68,
                            'T': 4.63, 'U': 3.93, 'M': 3.15, 'P': 2.51, 'B': 1.42,
                            'H': 1.08, 'Q': 1.01, 'V': 0.90, 'G': 0.89, 'F': 0.69,
                            'Y': 0.69, 'J': 0.52, 'Z': 0.47, 'X': 0.14, 'K': 0.02,
                            'W': 0.01
                        },
                        commonWords: ["EL", "LA", "LOS", "LAS", "UN", "UNA", "ES", "DEL", "QUE", "Y"]
                    }
                };
            }
            
            // Clean and validate input
            cleanInput(text, alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ') {
                const regex = new RegExp(`[^${alphabet}]`, 'gi');
                return text.toUpperCase().replace(regex, '');
            }
            
            // Kasiski examination to find likely key length
            kasiskiAnalysis(text, maxKeyLength = 20) {
    // 1. Ищем повторяющиеся триграммы (3-символьные последовательности)
    const trigrams = {};
    for (let i = 0; i < text.length - 2; i++) {
        const trigram = text.substr(i, 3);
        if (!trigrams[trigram]) trigrams[trigram] = [];
        trigrams[trigram].push(i);
    }

    // 2. Оставляем только триграммы, встречающиеся ≥2 раз
    const repeated = Object.entries(trigrams)
        .filter(([_, positions]) => positions.length >= 2)
        .map(([trigram, positions]) => ({
            trigram,
            positions,
            distances: []
        }));

    // 3. Вычисляем расстояния между повторами
    for (const seq of repeated) {
        const pos = seq.positions;
        for (let i = 1; i < pos.length; i++) {
            seq.distances.push(pos[i] - pos[i - 1]);
        }
    }

    // 4. Собираем все расстояния и их делители
    const allDistances = repeated.flatMap(seq => seq.distances);
    const factorCounts = {};

    for (const dist of allDistances) {
        for (let i = 2; i <= Math.min(dist, maxKeyLength); i++) {
            if (dist % i === 0) factorCounts[i] = (factorCounts[i] || 0) + 1;
        }
    }

    // 5. Выбираем 3 самых вероятных длины ключа
    const likelyLengths = Object.entries(factorCounts)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 3)
        .map(([len]) => parseInt(len));

    // 6. Добавляем резервные варианты, если данных мало
    if (likelyLengths.length === 0 || Math.max(...likelyLengths) > 10) {
        likelyLengths.push(6, 8, 10); // Типичные длины ключей
    }

    return {
        method: "Kasiski Examination",
        likelyKeyLengths: [...new Set(likelyLengths)], // Убираем дубли
        repeatedSequences: repeated,
        allDistances
    };
}
            
            // Friedman test to calculate index of coincidence
            friedmanTest(text, alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ') {
                const n = text.length;
                if (n < 2) return 0;
                
                // Calculate character frequencies
                const freq = {};
                for (const c of alphabet) freq[c] = 0;
                for (const c of text) freq[c]++;
                
                // Calculate index of coincidence
                let sum = 0;
                for (const c of alphabet) {
                    sum += freq[c] * (freq[c] - 1);
                }
                
                const ic = sum / (n * (n - 1));
                const ki = (ic - 1/alphabet.length) * alphabet.length / (n - 1);
                
                return {
                    method: "Friedman Test",
                    indexOfCoincidence: ic,
                    kappaPlaintext: ki,
                    expectedIC: {
                        random: 1/alphabet.length,
                        english: 0.0667,
                        french: 0.0778,
                        german: 0.0762,
                        spanish: 0.0770
                    },
                    interpretation: this.interpretIC(ic, alphabet.length)
                };
            }
            
            interpretIC(ic, alphabetSize) {
                const randomIC = 1 / alphabetSize;
                if (Math.abs(ic - randomIC) < 0.01) {
                    return "Likely random text or very strong cipher";
                } else if (ic > 0.06) {
                    return "Consistent with natural language (monoalphabetic substitution or weak polyalphabetic cipher)";
                } else {
                    return "Possible polyalphabetic cipher with longer key";
                }
            }
            
            // Frequency analysis
            frequencyAnalysis(text, language = 'english', alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ') {
                // Calculate observed frequencies
                const freq = {};
                for (const c of alphabet) freq[c] = 0;
                for (const c of text) freq[c]++;
                
                // Convert to percentages
                const total = text.length;
                const observed = Object.entries(freq)
                    .map(([char, count]) => ({
                        char,
                        count,
                        percent: (count / total) * 100
                    }))
                    .sort((a, b) => b.percent - a.percent);
                
                // Get expected frequencies for the language
                const expected = this.languageProfiles[language]?.frequencies || 
                               this.languageProfiles.english.frequencies;
                
                const expectedSorted = Object.entries(expected)
                    .map(([char, percent]) => ({ char, percent }))
                    .sort((a, b) => b.percent - a.percent);
                
                // Calculate chi-squared statistic
                let chiSquared = 0;
                for (const obs of observed) {
                    const expPercent = expected[obs.char] || 0;
                    const expectedCount = (expPercent / 100) * total;
                    if (expectedCount > 0) {
                        chiSquared += Math.pow(obs.count - expectedCount, 2) / expectedCount;
                    }
                }
                
                return {
                    method: "Frequency Analysis",
                    language: this.languageProfiles[language]?.name || "English",
                    observed: observed,
                    expected: expectedSorted,
                    chiSquared: chiSquared,
                    chiSquaredPerChar: chiSquared / alphabet.length,
                    interpretation: this.interpretChiSquared(chiSquared, alphabet.length)
                };
            }
            
            interpretChiSquared(chiSquared, degreesOfFreedom) {
                const ratio = chiSquared / degreesOfFreedom;
                if (ratio < 0.5) {
                    return "Very close match to expected frequencies";
                } else if (ratio < 1.5) {
                    return "Reasonable match to expected frequencies";
                } else if (ratio < 3.0) {
                    return "Some deviation from expected frequencies";
                } else {
                    return "Significant deviation from expected frequencies";
                }
            }
            
            // Vigenère decryption
            decrypt(text, key, alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ') {
                let result = '';
                const alphaLen = alphabet.length;
                
                for (let i = 0; i < text.length; i++) {
                    const textChar = text[i];
                    const keyChar = key[i % key.length];
                    
                    const textPos = alphabet.indexOf(textChar);
                    const keyPos = alphabet.indexOf(keyChar);
                    
                    if (textPos === -1) {
                        result += textChar; // Leave non-alphabet chars as-is
                        continue;
                    }
                    
                    const newPos = (textPos - keyPos + alphaLen) % alphaLen;
                    result += alphabet[newPos];
                }
                
                return result;
            }
            
            // Vigenère encryption
            encrypt(text, key, alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ') {
                let result = '';
                const alphaLen = alphabet.length;
                
                for (let i = 0; i < text.length; i++) {
                    const textChar = text[i];
                    const keyChar = key[i % key.length];
                    
                    const textPos = alphabet.indexOf(textChar);
                    const keyPos = alphabet.indexOf(keyChar);
                    
                    if (textPos === -1) {
                        result += textChar; // Leave non-alphabet chars as-is
                        continue;
                    }
                    
                    const newPos = (textPos + keyPos) % alphaLen;
                    result += alphabet[newPos];
                }
                
                return result;
            }
            
            // Score decrypted text based on language patterns
            scoreDecryption(decrypted, language = 'english', targetWords = []) {
                // Frequency score
                const freqAnalysis = this.frequencyAnalysis(decrypted, language);
                let score = 100 - Math.min(freqAnalysis.chiSquaredPerChar * 10, 100);
                
                // Common words score
                const commonWords = this.languageProfiles[language]?.commonWords || 
                                  this.languageProfiles.english.commonWords;
                
                let commonWordCount = 0;
                for (const word of commonWords) {
                    if (decrypted.includes(word)) {
                        commonWordCount++;
                    }
                }
                score += commonWordCount * 5;
                
                // Target words score
                let targetWordScore = 0;
                for (const word of targetWords) {
                    if (decrypted.includes(word.toUpperCase())) {
                        targetWordScore += 20;
                    }
                }
                score += targetWordScore;
                
                // Bigram and trigram scoring
                const commonBigrams = ["TH", "HE", "IN", "ER", "AN", "RE", "ND", "AT", "ON", "NT"];
                const commonTrigrams = ["THE", "AND", "THA", "ENT", "ING", "ION", "TIO", "FOR", "NDE", "HAS"];
                
                let bigramScore = 0;
                let trigramScore = 0;
                
                for (let i = 0; i < decrypted.length - 1; i++) {
                    const bigram = decrypted.substr(i, 2);
                    if (commonBigrams.includes(bigram)) bigramScore += 0.5;
                }
                
                for (let i = 0; i < decrypted.length - 2; i++) {
                    const trigram = decrypted.substr(i, 3);
                    if (commonTrigrams.includes(trigram)) trigramScore += 1;
                }
                
                score += bigramScore + trigramScore;
                
                return {
                    score: Math.round(score),
                    components: {
                        frequencyScore: 100 - Math.min(freqAnalysis.chiSquaredPerChar * 10, 100),
                        commonWordScore: commonWordCount * 5,
                        targetWordScore: targetWordScore,
                        bigramScore: Math.round(bigramScore),
                        trigramScore: Math.round(trigramScore)
                    }
                };
            }
            
            // Generate likely keys based on analysis
            generateKeys(text, keyLength, language = 'english', targetWords = []) {
                const keys = new Set();
                const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
                
                // Add target words if they match key length
                for (const word of targetWords) {
                    if (word.length === keyLength) {
                        keys.add(word.toUpperCase());
                    }
                }
                
                // Add common prefixes/suffixes
                const commonPrefixes = ["RE", "UN", "PRE", "OVER", "UNDER"];
                const commonSuffixes = ["ING", "TION", "MENT", "NESS", "ABLE"];
                
                if (keyLength >= 3) {
                    for (const prefix of commonPrefixes) {
                        if (prefix.length <= keyLength) {
                            let key = prefix;
                            while (key.length < keyLength) {
                                key += alphabet[Math.floor(Math.random() * alphabet.length)];
                            }
                            keys.add(key.toUpperCase());
                        }
                    }
                    
                    for (const suffix of commonSuffixes) {
                        if (suffix.length <= keyLength) {
                            let key = '';
                            while (key.length + suffix.length < keyLength) {
                                key += alphabet[Math.floor(Math.random() * alphabet.length)];
                            }
                            key += suffix;
                            keys.add(key.toUpperCase());
                        }
                    }
                }
                
                // Add some random keys
                for (let i = 0; i < 50; i++) {
                    let key = '';
                    for (let j = 0; j < keyLength; j++) {
                        key += alphabet[Math.floor(Math.random() * alphabet.length)];
                    }
                    keys.add(key);
                }
                
                return Array.from(keys);
            }
            
            // Full analysis combining all methods
            fullAnalysis(text, options = {}) {
                const {
                    maxKeyLength = 20,
                    language = 'english',
                    targetWords = [],
                    depth = 'standard'
                } = options;
                
                // Clean input
                const cleanedText = this.cleanInput(text);
                
                // Perform analyses
                const kasiski = this.kasiskiAnalysis(cleanedText, maxKeyLength);
                const friedman = this.friedmanTest(cleanedText);
                const freqAnalysis = this.frequencyAnalysis(cleanedText, language);
                
                // Determine likely key lengths to test
                const likelyKeyLengths = [...new Set([
                    kasiski.likelyKeyLengths[0]?.length || 1,
                    kasiski.likelyKeyLengths[1]?.length || 1,
                    Math.round(1 / (friedman.kappaPlaintext || 1))
                ].filter(l => l > 0 && l <= maxKeyLength))];
                
                // Generate and test keys
                const testResults = [];
                for (const keyLength of likelyKeyLengths) {
                    const keys = this.generateKeys(cleanedText, keyLength, language, targetWords);
                    
                    for (const key of keys) {
                        const decrypted = this.decrypt(cleanedText, key);
                        const score = this.scoreDecryption(decrypted, language, targetWords);
                        
                        testResults.push({
                            key,
                            keyLength,
                            decrypted,
                            score: score.score,
                            scoreComponents: score.components
                        });
                    }
                }
                
                // Sort results by score
                testResults.sort((a, b) => b.score - a.score);
                
                return {
                    kasiskiAnalysis: kasiski,
                    friedmanTest: friedman,
                    frequencyAnalysis: freqAnalysis,
                    testResults: testResults,
                    topResults: testResults.slice(0, 10),
                    likelyKeyLengths: likelyKeyLengths,
                    input: {
                        original: text,
                        cleaned: cleanedText,
                        length: cleanedText.length
                    },
                    options: options
                };
            }
        }
        
        // UI Functions
        function startFullAnalysis() {
            const input = document.getElementById('ciphertext').value;
            const maxKeyLength = parseInt(document.getElementById('max-key-length').value) || 20;
            const targetWords = document.getElementById('target-words').value
                .split(',')
                .map(w => w.trim())
                .filter(w => w.length > 0);
            const language = document.getElementById('language-profile').value;
            const depth = document.getElementById('analysis-depth').value;
            
            const analyzer = new K4Analyzer();
            const output = document.getElementById('output');
            output.innerHTML = '';
            
            // Show progress bar
            const progressContainer = document.getElementById('progress-container');
            const progressBar = document.getElementById('progress-bar');
            progressContainer.style.display = 'block';
            progressBar.style.width = '0%';
            
            // Simulate progress (in a real app, this would be actual progress)
            let progress = 0;
            const progressInterval = setInterval(() => {
                progress += Math.random() * 10;
                if (progress >= 100) {
                    progress = 100;
                    clearInterval(progressInterval);
                }
                progressBar.style.width = `${progress}%`;
            }, 200);
            
            // Run analysis (with slight delay to show progress)
            setTimeout(() => {
                try {
                    const results = analyzer.fullAnalysis(input, {
                        maxKeyLength,
                        language,
                        targetWords,
                        depth
                    });
                    
                    currentAnalysis = results;
                    displayAnalysisResults(results);
                    analysisHistory.push(results);
                    saveAnalysisHistory();
                    
                    // Hide progress bar
                    setTimeout(() => {
                        progressContainer.style.display = 'none';
                    }, 500);
                } catch (error) {
                    output.innerHTML = `<div class="alert alert-danger">
                        <i class="fas fa-exclamation-triangle"></i> Error during analysis: ${error.message}
                    </div>`;
                    progressContainer.style.display = 'none';
                }
            }, 1000);
        }
        
        function displayAnalysisResults(results) {
            const output = document.getElementById('output');
            output.innerHTML = '';
            
            // Summary card
            output.innerHTML += `
                <div class="result-card">
                    <h3>Analysis Summary</h3>
                    <p><strong>Input length:</strong> ${results.input.length} characters</p>
                    <p><strong>Language profile:</strong> ${results.frequencyAnalysis.language}</p>
                    <p><strong>Most likely key lengths:</strong> ${results.likelyKeyLengths.join(', ')}</p>
                    <p><strong>Index of Coincidence:</strong> ${results.friedmanTest.indexOfCoincidence.toFixed(4)} 
                        (${results.friedmanTest.interpretation})</p>
                    <p><strong>Chi-squared statistic:</strong> ${results.frequencyAnalysis.chiSquared.toFixed(2)} 
                        (${results.frequencyAnalysis.interpretation})</p>
                </div>
            `;
            
            // Kasiski results
            output.innerHTML += `
                <div class="result-card">
                    <h3>Kasiski Examination <span class="badge">Key Length Analysis</span></h3>
                    <p>This method looks for repeated sequences in the ciphertext to estimate the key length.</p>
                    
                    <h4>Most Likely Key Lengths</h4>
                    <div class="table-responsive">
                        <table>
                            <thead>
                                <tr>
                                    <th>Key Length</th>
                                    <th>Sequence Matches</th>
                                    <th>Confidence</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${results.kasiskiAnalysis.likelyKeyLengths.map(len => `
                                    <tr>
                                        <td>${len.length}</td>
                                        <td>${len.count}</td>
                                        <td>${(len.confidence * 100).toFixed(1)}%</td>
                                    </tr>
                                `).join('')}
                            </tbody>
                        </table>
                    </div>
                    
                    <h4>Repeated Sequences</h4>
                    <p>Found ${results.kasiskiAnalysis.repeatedSequences.length} repeated sequences:</p>
                    <div style="max-height: 200px; overflow-y: auto;">
                        <table>
                            <thead>
                                <tr>
                                    <th>Sequence</th>
                                    <th>Positions</th>
                                    <th>Distances</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${results.kasiskiAnalysis.repeatedSequences.slice(0, 20).map(seq => `
                                    <tr>
                                        <td><code>${seq.sequence}</code></td>
                                        <td>${seq.positions.join(', ')}</td>
                                        <td>${seq.distances.join(', ')}</td>
                                    </tr>
                                `).join('')}
                                ${results.kasiskiAnalysis.repeatedSequences.length > 20 ? `
                                    <tr>
                                        <td colspan="3">... and ${results.kasiskiAnalysis.repeatedSequences.length - 20} more</td>
                                    </tr>
                                ` : ''}
                            </tbody>
                        </table>
                    </div>
                </div>
            `;
            
            // Friedman test results
            output.innerHTML += `
                <div class="result-card">
                    <h3>Friedman Test <span class="badge">Index of Coincidence</span></h3>
                    <p>This method calculates the probability that two randomly selected letters are the same.</p>
                    
                    <div class="chart-container">
                        <canvas id="icChart"></canvas>
                    </div>
                    
                    <p><strong>Calculated Index of Coincidence:</strong> ${results.friedmanTest.indexOfCoincidence.toFixed(4)}</p>
                    <p><strong>Kappa Plaintext:</strong> ${results.friedmanTest.kappaPlaintext.toFixed(4)}</p>
                    <p><strong>Interpretation:</strong> ${results.friedmanTest.interpretation}</p>
                    
                    <h4>Expected Values for Comparison</h4>
                    <ul>
                        <li>Random text: ${results.friedmanTest.expectedIC.random.toFixed(4)}</li>
                        <li>English: ${results.friedmanTest.expectedIC.english.toFixed(4)}</li>
                        <li>French: ${results.friedmanTest.expectedIC.french.toFixed(4)}</li>
                        <li>German: ${results.friedmanTest.expectedIC.german.toFixed(4)}</li>
                        <li>Spanish: ${results.friedmanTest.expectedIC.spanish.toFixed(4)}</li>
                    </ul>
                </div>
            `;
            
            // Frequency analysis results
            output.innerHTML += `
                <div class="result-card">
                    <h3>Frequency Analysis <span class="badge">Character Distribution</span></h3>
                    <p>This compares the frequency of letters in the ciphertext to expected frequencies in ${results.frequencyAnalysis.language}.</p>
                    
                    <div class="chart-container">
                        <canvas id="freqChart"></canvas>
                    </div>
                    
                    <h4>Top Characters</h4>
                    <div class="table-responsive">
                        <table>
                            <thead>
                                <tr>
                                    <th>Character</th>
                                    <th>Count</th>
                                    <th>Percentage</th>
                                    <th>Expected</th>
                                    <th>Difference</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${results.frequencyAnalysis.observed.slice(0, 10).map(char => {
                                    const expected = results.frequencyAnalysis.expected.find(e => e.char === char.char)?.percent || 0;
                                    return `
                                        <tr>
                                            <td>${char.char}</td>
                                            <td>${char.count}</td>
                                            <td>${char.percent.toFixed(2)}%</td>
                                            <td>${expected.toFixed(2)}%</td>
                                            <td>${(char.percent - expected).toFixed(2)}%</td>
                                        </tr>
                                    `;
                                }).join('')}
                            </tbody>
                        </table>
                    </div>
                    
                    <p><strong>Chi-squared statistic:</strong> ${results.frequencyAnalysis.chiSquared.toFixed(2)}</p>
                    <p><strong>Interpretation:</strong> ${results.frequencyAnalysis.interpretation}</p>
                </div>
            `;
            
            // Test results
            output.innerHTML += `
                <div class="result-card">
                    <h3>Decryption Attempts <span class="badge">Top Results</span></h3>
                    <p>These are the highest scoring decryption attempts based on the analysis.</p>
                    
                    <div class="table-responsive">
                        <table>
                            <thead>
                                <tr>
                                    <th>Rank</th>
                                    <th>Key</th>
                                    <th>Key Length</th>
                                    <th>Score</th>
                                    <th>Decrypted Text</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${results.topResults.map((result, i) => `
                                    <tr>
                                        <td>${i + 1}</td>
                                        <td><strong>${result.key}</strong></td>
                                        <td>${result.keyLength}</td>
                                        <td>${result.score}</td>
                                        <td><code>${result.decrypted.substring(0, 50)}${result.decrypted.length > 50 ? '...' : ''}</code></td>
                                    </tr>
                                `).join('')}
                            </tbody>
                        </table>
                    </div>
                    
                    <button class="btn" onclick="showDetailedResults()">
                        <i class="fas fa-search-plus"></i> Show Detailed Results
                    </button>
                </div>
            `;
            
            // Render charts
            renderCharts(results);
        }
        
        function renderCharts(results) {
            // IC Comparison Chart
            const icCtx = document.getElementById('icChart').getContext('2d');
            new Chart(icCtx, {
                type: 'bar',
                data: {
                    labels: ['Your Text', 'Random', 'English', 'French', 'German', 'Spanish'],
                    datasets: [{
                        label: 'Index of Coincidence',
                        data: [
                            results.friedmanTest.indexOfCoincidence,
                            results.friedmanTest.expectedIC.random,
                            results.friedmanTest.expectedIC.english,
                            results.friedmanTest.expectedIC.french,
                            results.friedmanTest.expectedIC.german,
                            results.friedmanTest.expectedIC.spanish
                        ],
                        backgroundColor: [
                            'rgba(74, 111, 165, 0.7)',
                            'rgba(169, 169, 169, 0.7)',
                            'rgba(220, 53, 69, 0.7)',
                            'rgba(0, 123, 255, 0.7)',
                            'rgba(255, 193, 7, 0.7)',
                            'rgba(40, 167, 69, 0.7)'
                        ]
                    }]
                },
                options: {
                    responsive: true,
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Index of Coincidence'
                            }
                        }
                    }
                }
            });
            
            // Frequency Chart
            const freqCtx = document.getElementById('freqChart').getContext('2d');
            const topChars = results.frequencyAnalysis.observed.slice(0, 10);
            
            new Chart(freqCtx, {
                type: 'bar',
                data: {
                    labels: topChars.map(c => c.char),
                    datasets: [
                        {
                            label: 'Observed Frequency',
                            data: topChars.map(c => c.percent),
                            backgroundColor: 'rgba(74, 111, 165, 0.7)'
                        },
                        {
                            label: 'Expected Frequency',
                            data: topChars.map(c => {
                                const expected = results.frequencyAnalysis.expected.find(e => e.char === c.char);
                                return expected ? expected.percent : 0;
                            }),
                            backgroundColor: 'rgba(220, 53, 69, 0.7)'
                        }
                    ]
                },
                options: {
                    responsive: true,
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Percentage'
                            }
                        }
                    }
                }
            });
        }
        
        function showDetailedResults() {
            if (!currentAnalysis) return;
            
            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'block';
            modal.innerHTML = `
                <div class="modal-content">
                    <span class="close" onclick="this.parentElement.parentElement.style.display='none'">&times;</span>
                    <h2>Detailed Decryption Results</h2>
                    <p>Showing all ${currentAnalysis.testResults.length} tested keys, sorted by score.</p>
                    
                    <div class="table-responsive" style="max-height: 60vh; overflow-y: auto;">
                        <table>
                            <thead>
                                <tr>
                                    <th>Rank</th>
                                    <th>Key</th>
                                    <th>Key Length</th>
                                    <th>Score</th>
                                    <th>Frequency</th>
                                    <th>Common Words</th>
                                    <th>Target Words</th>
                                    <th>Decrypted Text</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${currentAnalysis.testResults.map((result, i) => `
                                    <tr>
                                        <td>${i + 1}</td>
                                        <td><strong>${result.key}</strong></td>
                                        <td>${result.keyLength}</td>
                                        <td>${result.score}</td>
                                        <td>${result.scoreComponents.frequencyScore}</td>
                                        <td>${result.scoreComponents.commonWordScore / 5}</td>
                                        <td>${result.scoreComponents.targetWordScore / 20}</td>
                                        <td><code>${result.decrypted.substring(0, 30)}${result.decrypted.length > 30 ? '...' : ''}</code></td>
                                    </tr>
                                `).join('')}
                            </tbody>
                        </table>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            // Close modal when clicking outside
            modal.addEventListener('click', function(e) {
                if (e.target === modal) {
                    modal.style.display = 'none';
                }
            });
        }
        
        // Vigenère Tools functions
        function processVigenere() {
            const text = document.getElementById('vigenere-text').value;
            const key = document.getElementById('vigenere-key').value;
            const mode = document.getElementById('vigenere-mode').value;
            const alphabetType = document.getElementById('vigenere-alphabet').value;
            
            let alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
            if (alphabetType === 'custom') {
                alphabet = document.getElementById('custom-alphabet').value.toUpperCase();
            }
            
            const analyzer = new K4Analyzer();
            let result;
            
            try {
                if (mode === 'encrypt') {
                    result = analyzer.encrypt(text, key, alphabet);
                } else {
                    result = analyzer.decrypt(text, key, alphabet);
                }
                
                document.getElementById('vigenere-output').innerHTML = `
                    <div class="result-card">
                        <h3>Vigenère ${mode === 'encrypt' ? 'Encryption' : 'Decryption'} Result</h3>
                        <p><strong>Key:</strong> ${key}</p>
                        <p><strong>Alphabet:</strong> ${alphabet}</p>
                        <pre>${result}</pre>
                        <button class="btn" onclick="copyToClipboard('${result.replace(/'/g, "\\'")}')">
                            <i class="fas fa-copy"></i> Copy to Clipboard
                        </button>
                    </div>
                `;
            } catch (error) {
                document.getElementById('vigenere-output').innerHTML = `
                    <div class="alert alert-danger">
                        <i class="fas fa-exclamation-triangle"></i> Error: ${error.message}
                    </div>
                `;
            }
        }
        
        function testKeyVariations() {
            const text = document.getElementById('vigenere-text').value;
            const baseKey = document.getElementById('vigenere-key').value;
            const alphabetType = document.getElementById('vigenere-alphabet').value;
            const language = document.getElementById('language-profile').value;
            
            if (!baseKey) {
                alert('Please enter a base key to test variations');
                return;
            }
            
            let alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
            if (alphabetType === 'custom') {
                alphabet = document.getElementById('custom-alphabet').value.toUpperCase();
            }
            
            const analyzer = new K4Analyzer();
            const variations = generateKeyVariations(baseKey);
            const results = [];
            
            // Show progress
            const output = document.getElementById('vigenere-output');
            output.innerHTML = `
                <div class="alert alert-info">
                    <i class="fas fa-spinner fa-spin"></i> Testing ${variations.length} key variations...
                </div>
            `;
            
            // Process in small chunks to keep UI responsive
            let processed = 0;
            const batchSize = 10;
            
            function processBatch() {
                const batch = variations.slice(processed, processed + batchSize);
                
                for (const key of batch) {
                    try {
                        const decrypted = analyzer.decrypt(text, key, alphabet);
                        const score = analyzer.scoreDecryption(decrypted, language);
                        results.push({ key, decrypted, score: score.score });
                    } catch (error) {
                        console.error(`Error with key ${key}:`, error);
                    }
                }
                
                processed += batchSize;
                
                // Update progress
                output.innerHTML = `
                    <div class="alert alert-info">
                        <i class="fas fa-spinner fa-spin"></i> Processed ${processed} of ${variations.length} key variations...
                    </div>
                `;
                
                if (processed < variations.length) {
                    setTimeout(processBatch, 10);
                } else {
                    // Done processing
                    displayKeyVariationResults(results);
                }
            }
            
            processBatch();
        }
        
        function generateKeyVariations(baseKey) {
            const variations = [baseKey];
            const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
            
            // Add uppercase/lowercase variations
            variations.push(baseKey.toUpperCase());
            variations.push(baseKey.toLowerCase());
            
            // Add common substitution variations
            const commonSubstitutions = {
                'A': ['4', '@'],
                'B': ['8', '6'],
                'E': ['3'],
                'G': ['9', '6'],
                'I': ['1', '!'],
                'O': ['0'],
                'S': ['5', '$'],
                'T': ['7', '+']
            };
            
            // Generate substitution variations
            for (let i = 0; i < baseKey.length; i++) {
                const char = baseKey[i].toUpperCase();
                if (commonSubstitutions[char]) {
                    for (const sub of commonSubstitutions[char]) {
                        const variation = baseKey.substring(0, i) + sub + baseKey.substring(i + 1);
                        variations.push(variation);
                    }
                }
            }
            
            // Add common prefix/suffix variations
            const commonPrefixes = ['THE', 'MY', 'OUR', 'SECRET', 'HIDDEN'];
            const commonSuffixes = ['KEY', 'CODE', 'PASS', 'WORD', '123'];
            
            for (const prefix of commonPrefixes) {
                variations.push(prefix + baseKey);
            }
            
            for (const suffix of commonSuffixes) {
                variations.push(baseKey + suffix);
            }
            
            // Add some random mutations
            for (let i = 0; i < 20; i++) {
                let variation = '';
                for (const char of baseKey) {
                    if (Math.random() < 0.3) {
                        variation += alphabet[Math.floor(Math.random() * alphabet.length)];
                    } else {
                        variation += char;
                    }
                }
                variations.push(variation);
            }
            
            return [...new Set(variations.filter(v => v.length > 0))];
        }
        
        function displayKeyVariationResults(results) {
            // Sort by score
            results.sort((a, b) => b.score - a.score);
            
            const output = document.getElementById('vigenere-output');
            output.innerHTML = `
                <div class="result-card">
                    <h3>Key Variation Test Results</h3>
                    <p>Tested ${results.length} variations of the base key.</p>
                    
                    <div class="table-responsive">
                        <table>
                            <thead>
                                <tr>
                                    <th>Rank</th>
                                    <th>Key</th>
                                    <th>Score</th>
                                    <th>Decrypted Text</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${results.slice(0, 20).map((result, i) => `
                                    <tr>
                                        <td>${i + 1}</td>
                                        <td><strong>${result.key}</strong></td>
                                        <td>${result.score}</td>
                                        <td><code>${result.decrypted.substring(0, 30)}${result.decrypted.length > 30 ? '...' : ''}</code></td>
                                    </tr>
                                `).join('')}
                            </tbody>
                        </table>
                    </div>
                </div>
            `;
        }
        
        function findLikelyKeyLength() {
            const text = document.getElementById('vigenere-text').value;
            const maxKeyLength = parseInt(document.getElementById('max-key-length').value) || 20;
            
            const analyzer = new K4Analyzer();
            const kasiski = analyzer.kasiskiAnalysis(text, maxKeyLength);
            const friedman = analyzer.friedmanTest(text);
            
            const likelyKeyLengths = [...new Set([
                kasiski.likelyKeyLengths[0]?.length || 1,
                kasiski.likelyKeyLengths[1]?.length || 1,
                Math.round(1 / (friedman.kappaPlaintext || 1))
            ].filter(l => l > 0 && l <= maxKeyLength))];
            
            document.getElementById('vigenere-output').innerHTML = `
                <div class="result-card">
                    <h3>Key Length Analysis</h3>
                    <p><strong>Most likely key lengths:</strong> ${likelyKeyLengths.join(', ')}</p>
                    
                    <h4>Kasiski Examination Results</h4>
                    <div class="table-responsive">
                        <table>
                            <thead>
                                <tr>
                                    <th>Key Length</th>
                                    <th>Sequence Matches</th>
                                    <th>Confidence</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${kasiski.likelyKeyLengths.map(len => `
                                    <tr>
                                        <td>${len.length}</td>
                                        <td>${len.count}</td>
                                        <td>${(len.confidence * 100).toFixed(1)}%</td>
                                    </tr>
                                `).join('')}
                            </tbody>
                        </table>
                    </div>
                    
                    <h4>Friedman Test Results</h4>
                    <p><strong>Index of Coincidence:</strong> ${friedman.indexOfCoincidence.toFixed(4)}</p>
                    <p><strong>Kappa Plaintext:</strong> ${friedman.kappaPlaintext.toFixed(4)}</p>
                    <p><strong>Estimated key length:</strong> ${Math.round(1 / (friedman.kappaPlaintext || 1))}</p>
                </div>
            `;
        }
        
        // Custom Alphabet functions
        function updateFrequencyInputs() {
            const chars = document.getElementById('alphabet-chars').value.toUpperCase();
            const uniqueChars = [...new Set(chars.split('').filter(c => c.trim()))].sort();
            
            const container = document.getElementById('frequency-inputs');
            container.innerHTML = '';
            
            for (const char of uniqueChars) {
                const inputGroup = document.createElement('div');
                inputGroup.style.marginBottom = '5px';
                inputGroup.innerHTML = `
                    <label style="display: inline-block; width: 30px;">${char}:</label>
                    <input type="number" id="freq-${char}" min="0" max="100" step="0.01" 
                           style="width: 80px; padding: 3px;"> %
                `;
                container.appendChild(inputGroup);
            }
        }
        
        function saveCustomAlphabet() {
            const name = document.getElementById('alphabet-name').value.trim();
            const chars = document.getElementById('alphabet-chars').value.toUpperCase();
            
            if (!name || !chars) {
                alert('Please provide both a name and characters for the alphabet');
                return;
            }
            
            // Get frequencies
            const uniqueChars = [...new Set(chars.split('').filter(c => c.trim()))];
            const frequencies = {};
            let total = 0;
            
            for (const char of uniqueChars) {
                const freqInput = document.getElementById(`freq-${char}`);
                if (freqInput) {
                    const value = parseFloat(freqInput.value) || 0;
                    frequencies[char] = value;
                    total += value;
                }
            }
            
            // Normalize frequencies if they don't sum to 100%
            if (total > 0 && Math.abs(total - 100) > 0.01) {
                if (confirm(`Frequencies sum to ${total.toFixed(2)}%. Would you like to normalize them to 100%?`)) {
                    for (const char in frequencies) {
                        frequencies[char] = (frequencies[char] / total) * 100;
                    }
                }
            }
            
            // Save alphabet
            customAlphabets[name] = {
                characters: chars,
                frequencies: frequencies
            };
            
            saveCustomAlphabets();
            
            document.getElementById('custom-alphabet-output').innerHTML = `
                <div class="alert alert-success">
                    <i class="fas fa-check-circle"></i> Alphabet "${name}" saved successfully!
                </div>
            `;
        }
        
        function loadCustomAlphabet() {
            const name = prompt('Enter the name of the alphabet to load:');
            if (!name || !customAlphabets[name]) {
                alert('Alphabet not found');
                return;
            }
            
            const alphabet = customAlphabets[name];
            document.getElementById('alphabet-name').value = name;
            document.getElementById('alphabet-chars').value = alphabet.characters;
            
            updateFrequencyInputs();
            
            // Set frequency values
            for (const char in alphabet.frequencies) {
                const freqInput = document.getElementById(`freq-${char}`);
                if (freqInput) {
                    freqInput.value = alphabet.frequencies[char].toFixed(2);
                }
            }
            
            document.getElementById('custom-alphabet-output').innerHTML = `
                <div class="alert alert-success">
                    <i class="fas fa-check-circle"></i> Alphabet "${name}" loaded successfully!
                </div>
            `;
        }
        
        function testCustomAlphabet() {
            const chars = document.getElementById('alphabet-chars').value.toUpperCase();
            const uniqueChars = [...new Set(chars.split('').filter(c => c.trim()))];
            
            if (uniqueChars.length < 5) {
                alert('Alphabet must contain at least 5 unique characters');
                return;
            }
            
            // Check frequencies if provided
            let frequencies = {};
            let totalFreq = 0;
            let hasFrequencies = false;
            
            for (const char of uniqueChars) {
                const freqInput = document.getElementById(`freq-${char}`);
                if (freqInput && freqInput.value) {
                    const value = parseFloat(freqInput.value);
                    if (!isNaN(value)) {
                        frequencies[char] = value;
                        totalFreq += value;
                        hasFrequencies = true;
                    }
                }
            }
            
            // Generate test output
            let output = `
                <div class="result-card">
                    <h3>Alphabet Test Results</h3>
                    <p><strong>Characters:</strong> ${chars}</p>
                    <p><strong>Unique characters:</strong> ${uniqueChars.length}</p>
            `;
            
            if (hasFrequencies) {
                output += `
                    <p><strong>Total frequency:</strong> ${totalFreq.toFixed(2)}%</p>
                    <div class="histogram">
                        ${uniqueChars.map(char => {
                            const freq = frequencies[char] || 0;
                            const height = (freq / 100) * 200;
                            return `
                                <div class="histogram-bar" style="height: ${height}px" 
                                     title="${char}: ${freq.toFixed(2)}%">
                                    <div class="histogram-value">${freq.toFixed(1)}%</div>
                                    <div class="histogram-label">${char}</div>
                                </div>
                            `;
                        }).join('')}
                    </div>
                `;
            }
            
            output += `</div>`;
            
            document.getElementById('custom-alphabet-output').innerHTML = output;
        }
        
        // Reports functions
        function generateFullReport() {
            if (!currentAnalysis) {
                alert('No analysis results available to generate report');
                return;
            }
            
            const report = `
                <div class="result-card">
                    <h3>Full Analysis Report</h3>
                    <p><strong>Date:</strong> ${new Date().toLocaleString()}</p>
                    <p><strong>Input text:</strong> ${currentAnalysis.input.cleaned}</p>
                    <p><strong>Input length:</strong> ${currentAnalysis.input.length} characters</p>
                    <p><strong>Language profile:</strong> ${currentAnalysis.frequencyAnalysis.language}</p>
                    
                    <h4>Key Length Analysis</h4>
                    <p><strong>Most likely key lengths:</strong> ${currentAnalysis.likelyKeyLengths.join(', ')}</p>
                    
                    <h4>Friedman Test</h4>
                    <p><strong>Index of Coincidence:</strong> ${currentAnalysis.friedmanTest.indexOfCoincidence.toFixed(4)}</p>
                    <p><strong>Interpretation:</strong> ${currentAnalysis.friedmanTest.interpretation}</p>
                    
                    <h4>Frequency Analysis</h4>
                    <p><strong>Chi-squared statistic:</strong> ${currentAnalysis.frequencyAnalysis.chiSquared.toFixed(2)}</p>
                    <p><strong>Interpretation:</strong> ${currentAnalysis.frequencyAnalysis.interpretation}</p>
                    
                    <h4>Top 10 Decryption Attempts</h4>
                    <div class="table-responsive">
                        <table>
                            <thead>
                                <tr>
                                    <th>Rank</th>
                                    <th>Key</th>
                                    <th>Score</th>
                                    <th>Decrypted Text</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${currentAnalysis.topResults.map((result, i) => `
                                    <tr>
                                        <td>${i + 1}</td>
                                        <td>${result.key}</td>
                                        <td>${result.score}</td>
                                        <td><code>${result.decrypted.substring(0, 50)}${result.decrypted.length > 50 ? '...' : ''}</code></td>
                                    </tr>
                                `).join('')}
                            </tbody>
                        </table>
                    </div>
                    
                    <button class="btn" onclick="printReport()">
                        <i class="fas fa-print"></i> Print Report
                    </button>
                    <button class="btn btn-outline" onclick="exportToPDF()">
                        <i class="fas fa-file-pdf"></i> Export to PDF
                    </button>
                </div>
            `;
            
            document.getElementById('report-output').innerHTML = report;
        }
        
        function exportToCSV() {
            if (!currentAnalysis) {
                alert('No analysis results available to export');
                return;
            }
            
            let csv = "Rank,Key,Key Length,Score,Decrypted Text\n";
            
            currentAnalysis.testResults.forEach((result, i) => {
                csv += `${i + 1},"${result.key}",${result.keyLength},${result.score},"${result.decrypted.replace(/"/g, '""')}"\n`;
            });
            
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `k4-analysis-${new Date().toISOString().slice(0, 10)}.csv`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
        
        function exportToJSON() {
            if (!currentAnalysis) {
                alert('No analysis results available to export');
                return;
            }
            
            const data = {
                metadata: {
                    date: new Date().toISOString(),
                    inputLength: currentAnalysis.input.length,
                    language: currentAnalysis.frequencyAnalysis.language
                },
                kasiskiAnalysis: currentAnalysis.kasiskiAnalysis,
                friedmanTest: currentAnalysis.friedmanTest,
                frequencyAnalysis: currentAnalysis.frequencyAnalysis,
                topResults: currentAnalysis.topResults
            };
            
            const json = JSON.stringify(data, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `k4-analysis-${new Date().toISOString().slice(0, 10)}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
        
        function printReport() {
            window.print();
        }
        
        function exportToPDF() {
            alert('PDF export would be implemented with a library like jsPDF in a real application');
        }
        
        // Utility functions
        function copyToClipboard(text) {
            navigator.clipboard.writeText(text).then(() => {
                alert('Copied to clipboard!');
            }).catch(err => {
                alert('Failed to copy: ' + err);
            });
        }
        
        function clearResults() {
            document.getElementById('output').innerHTML = '';
            currentAnalysis = null;
        }
        
        function saveAnalysis() {
            if (!currentAnalysis) {
                alert('No analysis results to save');
                return;
            }
            
            // In a real app, this would save to a database or file
            alert('Analysis saved (in a real app, this would persist the data)');
        }
        
        function saveAnalysisHistory() {
            localStorage.setItem('k4AnalysisHistory', JSON.stringify(analysisHistory));
        }
        
        function saveCustomAlphabets() {
            localStorage.setItem('k4CustomAlphabets', JSON.stringify(customAlphabets));
        }
        
        function saveSettings() {
            const settings = {
                maxResults: document.getElementById('max-results').value,
                autoSave: document.getElementById('auto-save').value,
                theme: document.getElementById('theme').value,
                fontSize: document.getElementById('font-size').value
            };
            
            localStorage.setItem('k4Settings', JSON.stringify(settings));
            closeModal('settingsModal');
            alert('Settings saved');
        }
        
        function loadSavedData() {
            // Load analysis history
            const savedHistory = localStorage.getItem('k4AnalysisHistory');
            if (savedHistory) {
                analysisHistory = JSON.parse(savedHistory);
                if (analysisHistory.length > 0) {
                    currentAnalysis = analysisHistory[analysisHistory.length - 1];
                }
            }
            
            // Load custom alphabets
            const savedAlphabets = localStorage.getItem('k4CustomAlphabets');
            if (savedAlphabets) {
                customAlphabets = JSON.parse(savedAlphabets);
            }
            
            // Load settings
            const savedSettings = localStorage.getItem('k4Settings');
            if (savedSettings) {
                const settings = JSON.parse(savedSettings);
                document.getElementById('max-results').value = settings.maxResults;
                document.getElementById('auto-save').value = settings.autoSave;
                document.getElementById('theme').value = settings.theme;
                document.getElementById('font-size').value = settings.fontSize;
                
                // Apply theme
                applyTheme(settings.theme);
                applyFontSize(settings.fontSize);
            }
        }
        
        function applyTheme(theme) {
            // In a real app, this would change CSS variables
            console.log('Applying theme:', theme);
        }
        
        function applyFontSize(size) {
            let fontSize;
            switch (size) {
                case 'small': fontSize = '14px'; break;
                case 'large': fontSize = '18px'; break;
                default: fontSize = '16px';
            }
            
            document.body.style.fontSize = fontSize;
        }
    </script>
</body>
</html>
