<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–ü—Ä–æ–¥–≤–∏–Ω—É—Ç—ã–π –¥–µ–∫–æ–¥–µ—Ä —à–∏—Ñ—Ä–∞ –í–∏–∂–µ–Ω–µ—Ä–∞</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f9f9f9;
        }
        h1 {
            color: #2c3e50;
            text-align: center;
            margin-bottom: 30px;
        }
        .container {
            background: white;
            border-radius: 8px;
            padding: 25px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        textarea {
            width: 100%;
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 16px;
            margin-bottom: 15px;
            min-height: 150px;
            resize: vertical;
        }
        button {
            background: #3498db;
            color: white;
            border: none;
            padding: 12px 20px;
            font-size: 16px;
            border-radius: 4px;
            cursor: pointer;
            width: 100%;
            transition: background 0.3s;
            margin-bottom: 10px;
        }
        button:hover {
            background: #2980b9;
        }
        button.secondary {
            background: #7f8c8d;
        }
        button.secondary:hover {
            background: #6c7a7d;
        }
        .result-area {
            margin-top: 25px;
            padding: 20px;
            background: #f0f8ff;
            border-radius: 4px;
            border-left: 4px solid #3498db;
        }
        .settings {
            margin: 20px 0;
            padding: 15px;
            background: #f5f5f5;
            border-radius: 4px;
        }
        .error {
            color: #e74c3c;
            font-weight: bold;
        }
        .success {
            color: #27ae60;
        }
        .key-candidate {
            margin: 10px 0;
            padding: 10px;
            background: #fff;
            border-radius: 4px;
            border: 1px solid #ddd;
        }
        .progress-container {
            width: 100%;
            background-color: #e0e0e0;
            border-radius: 4px;
            margin: 10px 0;
        }
        .progress-bar {
            height: 20px;
            background-color: #3498db;
            border-radius: 4px;
            width: 0%;
            transition: width 0.3s;
            text-align: center;
            color: white;
            font-size: 12px;
            line-height: 20px;
        }
        .settings-row {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-bottom: 15px;
        }
        .settings-group {
            flex: 1;
            min-width: 200px;
            background: #eaf2f8;
            padding: 10px;
            border-radius: 4px;
        }
        .settings-group h4 {
            margin-top: 0;
            color: #2c3e50;
        }
        label {
            display: block;
            margin-bottom: 5px;
        }
        input[type="range"] {
            width: 100%;
        }
        select {
            width: 100%;
            padding: 8px;
            margin-bottom: 10px;
            border-radius: 4px;
            border: 1px solid #ddd;
        }
        .key-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 10px;
            margin-top: 15px;
        }
        .key-info {
            cursor: pointer;
            transition: background 0.2s;
        }
        .key-info:hover {
            background: #eaf2f8;
        }
        .highlight {
            background-color: #fffacd;
        }
        .analysis-section {
            margin-top: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 4px;
        }
        .tab-buttons {
            display: flex;
            margin-bottom: 15px;
        }
        .tab-button {
            padding: 10px 15px;
            background: #ddd;
            border: none;
            cursor: pointer;
            margin-right: 5px;
            border-radius: 4px 4px 0 0;
        }
        .tab-button.active {
            background: #3498db;
            color: white;
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }
        .stats-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
        }
        .stats-table th, .stats-table td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        .stats-table th {
            background-color: #f2f2f2;
        }
        .stats-table tr:nth-child(even) {
            background-color: #f9f9f9;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üîç –ü—Ä–æ–¥–≤–∏–Ω—É—Ç—ã–π –¥–µ–∫–æ–¥–µ—Ä —à–∏—Ñ—Ä–∞ –í–∏–∂–µ–Ω–µ—Ä–∞</h1>
        
        <div class="settings">
            <h3>–ù–∞—Å—Ç—Ä–æ–π–∫–∏ –∞–Ω–∞–ª–∏–∑–∞</h3>
            
            <div class="settings-row">
                <div class="settings-group">
                    <h4>–ü–∞—Ä–∞–º–µ—Ç—Ä—ã –∫–ª—é—á–∞</h4>
                    <label>
                        –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è –¥–ª–∏–Ω–∞ –∫–ª—é—á–∞:
                        <input type="range" id="keyLength" min="1" max="30" value="15" oninput="updateKeyLength()">
                        <span id="keyLengthValue">15</span>
                    </label>
                    
                    <label>
                        –ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è –¥–ª–∏–Ω–∞ –∫–ª—é—á–∞:
                        <input type="range" id="minKeyLength" min="1" max="15" value="1" oninput="updateMinKeyLength()">
                        <span id="minKeyLengthValue">1</span>
                    </label>
                    
                    <label>
                        –ú–µ—Ç–æ–¥ –∞–Ω–∞–ª–∏–∑–∞:
                        <select id="analysisMethod">
                            <option value="auto">–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π (—á–∞—Å—Ç–æ—Ç–Ω—ã–π –∞–Ω–∞–ª–∏–∑)</option>
                            <option value="bruteforce">–ë—Ä—É—Ç—Ñ–æ—Ä—Å (–≤—Å–µ –≤–æ–∑–º–æ–∂–Ω—ã–µ –∫–ª—é—á–∏)</option>
                            <option value="known-length">–ò–∑–≤–µ—Å—Ç–Ω–∞—è –¥–ª–∏–Ω–∞ –∫–ª—é—á–∞</option>
                        </select>
                    </label>
                </div>
                
                <div class="settings-group">
                    <h4>–ü–∞—Ä–∞–º–µ—Ç—Ä—ã —Ç–µ–∫—Å—Ç–∞</h4>
                    <label>
                        –Ø–∑—ã–∫ —Ç–µ–∫—Å—Ç–∞:
                        <select id="language">
                            <option value="english">–ê–Ω–≥–ª–∏–π—Å–∫–∏–π</option>
                            <option value="russian">–†—É—Å—Å–∫–∏–π</option>
                        </select>
                    </label>
                    
                    <label>
                        –£—á–∏—Ç—ã–≤–∞—Ç—å —Ä–µ–≥–∏—Å—Ç—Ä:
                        <input type="checkbox" id="preserveCase" checked>
                    </label>
                    
                    <label>
                        –°–æ—Ö—Ä–∞–Ω—è—Ç—å –ø—Ä–æ–±–µ–ª—ã –∏ –∑–Ω–∞–∫–∏:
                        <input type="checkbox" id="preserveSpaces" checked>
                    </label>
                </div>
                
                <div class="settings-group">
                    <h4>–î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã</h4>
                    <label>
                        –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ —á–∏—Å–ª–æ –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤:
                        <input type="number" id="maxResults" min="1" max="50" value="10">
                    </label>
                    
                    <label>
                        –ü–æ—Ä–æ–≥ –∫–∞—á–µ—Å—Ç–≤–∞:
                        <input type="range" id="qualityThreshold" min="0" max="100" value="50">
                        <span id="qualityThresholdValue">50</span>%
                    </label>
                </div>
            </div>
        </div>

        <textarea id="ciphertext" placeholder="–í–≤–µ–¥–∏—Ç–µ –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã–π —Ç–µ–∫—Å—Ç...">OBKRUOXOGHULBSOLIFBBWFLRVQQPRNGKSSOTWTQSJQSSEKZZWATJKLUDIAWINFBNYPVTTMZFPKWGDKZXTJCDIGKUHUAUEKCAR</textarea>
        
        <button onclick="startAnalysis()">–ó–∞–ø—É—Å—Ç–∏—Ç—å –∞–Ω–∞–ª–∏–∑</button>
        <button class="secondary" onclick="stopAnalysis()" id="stopButton" disabled>–û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –∞–Ω–∞–ª–∏–∑</button>
        
        <div class="progress-container">
            <div class="progress-bar" id="progressBar">0%</div>
        </div>
        
        <div class="result-area">
            <div class="tab-buttons">
                <button class="tab-button active" onclick="switchTab('results')">–†–µ–∑—É–ª—å—Ç–∞—Ç—ã</button>
                <button class="tab-button" onclick="switchTab('analysis')">–ê–Ω–∞–ª–∏–∑ –∫–ª—é—á–∞</button>
                <button class="tab-button" onclick="switchTab('stats')">–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞</button>
            </div>
            
            <div id="status">–ì–æ—Ç–æ–≤ –∫ —Ä–∞–±–æ—Ç–µ. –í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç –∏ –Ω–∞–∂–º–∏—Ç–µ "–ó–∞–ø—É—Å—Ç–∏—Ç—å –∞–Ω–∞–ª–∏–∑".</div>
            
            <div id="results" class="tab-content active">
                <h3>–õ—É—á—à–∏–µ –≤–∞—Ä–∏–∞–Ω—Ç—ã —Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∫–∏:</h3>
                <div id="result"></div>
                <div id="candidates" class="key-grid"></div>
            </div>
            
            <div id="analysis" class="tab-content">
                <h3>–ê–Ω–∞–ª–∏–∑ –≤–æ–∑–º–æ–∂–Ω—ã—Ö –∫–ª—é—á–µ–π</h3>
                <div id="keyAnalysis"></div>
            </div>
            
            <div id="stats" class="tab-content">
                <h3>–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ —Ç–µ–∫—Å—Ç–∞</h3>
                <div id="textStats"></div>
            </div>
        </div>
    </div>

    <script>
        // –ß–∞—Å—Ç–æ—Ç–Ω–æ—Å—Ç—å –±—É–∫–≤ –≤ —Ä–∞–∑–Ω—ã—Ö —è–∑—ã–∫–∞—Ö
        const languageFrequencies = {
            english: {
                name: "–ê–Ω–≥–ª–∏–π—Å–∫–∏–π",
                frequencies: {
                    'A': 8.167, 'B': 1.492, 'C': 2.782, 'D': 4.253, 'E': 12.702,
                    'F': 2.228, 'G': 2.015, 'H': 6.094, 'I': 6.966, 'J': 0.153,
                    'K': 0.772, 'L': 4.025, 'M': 2.406, 'N': 6.749, 'O': 7.507,
                    'P': 1.929, 'Q': 0.095, 'R': 5.987, 'S': 6.327, 'T': 9.056,
                    'U': 2.758, 'V': 0.978, 'W': 2.360, 'X': 0.150, 'Y': 1.974,
                    'Z': 0.074
                },
                commonBigrams: [
                    'EAST', 'ESTNORTH', 'NORTH', 'BERLIN', 'CLOCK'
                ],
                commonTrigrams: [
                    'THEBERLIN', 'EAST', 'NORTHEST', 'NORTH', 'BERLIN', 'CLOCK'
                ],
                commonWords: [
                    'THECLOK', 'BERLINCLOCK', 'EAST', 'ESTNORTH', 'NORTH', 'BERLIN', 'CLOCK'
                ]
            },
            russian: {
                name: "–†—É—Å—Å–∫–∏–π",
                frequencies: {
                    '–ê': 8.01, '–ë': 1.59, '–í': 4.54, '–ì': 1.70, '–î': 2.98,
                    '–ï': 8.45, '–Å': 0.04, '–ñ': 0.94, '–ó': 1.65, '–ò': 7.35,
                    '–ô': 1.21, '–ö': 3.49, '–õ': 4.40, '–ú': 3.21, '–ù': 6.70,
                    '–û': 10.97, '–ü': 2.81, '–†': 4.73, '–°': 5.47, '–¢': 6.26,
                    '–£': 2.62, '–§': 0.26, '–•': 0.97, '–¶': 0.48, '–ß': 1.44,
                    '–®': 0.73, '–©': 0.36, '–™': 0.04, '–´': 1.90, '–¨': 1.74,
                    '–≠': 0.32, '–Æ': 0.64, '–Ø': 2.01
                },
                commonBigrams: [
                    '–°–¢', '–ù–û', '–ï–ù', '–¢–û', '–ù–ê', '–û–í', '–ù–ò', '–†–ê',
                    '–í–û', '–ö–û', '–ï–õ', '–†–û', '–û–õ', '–¢–ï', '–õ–¨', '–ù–ï'
                ],
                commonTrigrams: [
                    '–°–¢–û', '–ï–ù–û', '–ù–û–í', '–¢–û–í', '–û–í–û', '–û–í–ê', '–ï–ù–ò', '–†–ê–ó',
                    '–ü–†–û', '–ì–û–î', '–†–û–î', '–ö–û–¢', '–û–†–û', '–¢–ê–ö', '–û–ì–û', '–¢–û–†'
                ],
                commonWords: [
                    '–ò', '–í', '–ù–ï', '–ù–ê', '–Ø', '–ë–´–¢–¨', '–û–ù', '–°',
                    '–ß–¢–û', '–ê', '–≠–¢–û', '–í–ï–°–¨', '–û–ù–ê', '–ü–û', '–ù–û', '–û–ù–ò',
                    '–ö', '–£', '–¢–´', '–ï–ì–û', '–ó–ê', '–ò–ó', '–ú–´', '–í–´'
                ]
            }
        };

        // –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –ø—Ä–æ—Ü–µ—Å—Å–æ–º –∞–Ω–∞–ª–∏–∑–∞
        let isAnalyzing = false;
        let stopRequested = false;
        let currentLanguage = 'english';
        let currentFrequencies = languageFrequencies.english;
        
        // –û–±–Ω–æ–≤–ª—è–µ–º –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ –¥–ª–∏–Ω—ã –∫–ª—é—á–∞
        function updateKeyLength() {
            const slider = document.getElementById('keyLength');
            const display = document.getElementById('keyLengthValue');
            display.textContent = slider.value;
            
            // –û–±–Ω–æ–≤–ª—è–µ–º –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–π –¥–ª–∏–Ω—ã
            const minSlider = document.getElementById('minKeyLength');
            minSlider.max = slider.value;
            if (parseInt(minSlider.value) > parseInt(slider.value)) {
                minSlider.value = slider.value;
                document.getElementById('minKeyLengthValue').textContent = slider.value;
            }
        }
        
        function updateMinKeyLength() {
            const slider = document.getElementById('minKeyLength');
            const display = document.getElementById('minKeyLengthValue');
            display.textContent = slider.value;
        }
        
        function updateQualityThreshold() {
            const slider = document.getElementById('qualityThreshold');
            const display = document.getElementById('qualityThresholdValue');
            display.textContent = slider.value;
        }
        
        // –ü–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ –º–µ–∂–¥—É –≤–∫–ª–∞–¥–∫–∞–º–∏
        function switchTab(tabName) {
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.remove('active');
            });
            document.querySelectorAll('.tab-button').forEach(button => {
                button.classList.remove('active');
            });
            
            document.getElementById(tabName).classList.add('active');
            document.querySelector(`.tab-button[onclick="switchTab('${tabName}')"]`).classList.add('active');
        }
        
        // –û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –∑–∞–ø—É—Å–∫–∞ –∞–Ω–∞–ª–∏–∑–∞
        function startAnalysis() {
            if (isAnalyzing) return;
            
            // –û—á–∏—â–∞–µ–º –ø—Ä–µ–¥—ã–¥—É—â–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã
            document.getElementById('result').innerHTML = '';
            document.getElementById('candidates').innerHTML = '';
            document.getElementById('keyAnalysis').innerHTML = '';
            document.getElementById('textStats').innerHTML = '';
            document.getElementById('progressBar').style.width = '0%';
            document.getElementById('progressBar').textContent = '0%';
            
            // –ü–æ–ª—É—á–∞–µ–º –Ω–∞—Å—Ç—Ä–æ–π–∫–∏
            const maxKeyLength = parseInt(document.getElementById('keyLength').value);
            const minKeyLength = parseInt(document.getElementById('minKeyLength').value);
            const analysisMethod = document.getElementById('analysisMethod').value;
            const maxResults = parseInt(document.getElementById('maxResults').value);
            const qualityThreshold = parseInt(document.getElementById('qualityThreshold').value) / 100;
            currentLanguage = document.getElementById('language').value;
            currentFrequencies = languageFrequencies[currentLanguage];
            
            // –ü–æ–ª—É—á–∞–µ–º –∏ –æ—á–∏—â–∞–µ–º —Ç–µ–∫—Å—Ç
            let ciphertext = document.getElementById('ciphertext').value;
            const preserveCase = document.getElementById('preserveCase').checked;
            const preserveSpaces = document.getElementById('preserveSpaces').checked;
            
            if (!ciphertext) {
                document.getElementById('status').innerHTML = '<span class="error">–í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞!</span>';
                return;
            }
            
            // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ñ–ª–∞–≥ –∞–Ω–∞–ª–∏–∑–∞
            isAnalyzing = true;
            stopRequested = false;
            document.getElementById('stopButton').disabled = false;
            document.getElementById('status').innerHTML = '–ê–Ω–∞–ª–∏–∑–∏—Ä—É—é —Ç–µ–∫—Å—Ç...';
            
            // –ó–∞–ø—É—Å–∫–∞–µ–º –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–º –ø–æ—Ç–æ–∫–µ, —á—Ç–æ–±—ã –Ω–µ –±–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å
            setTimeout(() => {
                try {
                    const startTime = performance.now();
                    
                    // –û—á–∏—â–∞–µ–º —Ç–µ–∫—Å—Ç (—Å–æ—Ö—Ä–∞–Ω—è–µ–º –æ—Ä–∏–≥–∏–Ω–∞–ª –¥–ª—è –≤—ã–≤–æ–¥–∞)
                    const originalText = ciphertext;
                    ciphertext = prepareText(ciphertext, preserveCase, preserveSpaces);
                    
                    // –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º —Ç–µ–∫—Å—Ç –∏ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
                    analyzeTextStats(ciphertext);
                    
                    // –í –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ –º–µ—Ç–æ–¥–∞ –∑–∞–ø—É—Å–∫–∞–µ–º –∞–Ω–∞–ª–∏–∑
                    let resultsPromise;
                    
                    if (analysisMethod === 'bruteforce') {
                        resultsPromise = bruteForceAnalysis(ciphertext, minKeyLength, maxKeyLength, maxResults, qualityThreshold);
                    } else if (analysisMethod === 'known-length') {
                        resultsPromise = analyzeKnownLength(ciphertext, maxKeyLength, maxResults);
                    } else {
                        resultsPromise = autoAnalysis(ciphertext, minKeyLength, maxKeyLength, maxResults, qualityThreshold);
                    }
                    
                    resultsPromise.then(results => {
                        if (stopRequested) return;
                        
                        const endTime = performance.now();
                        
                        // –í—ã–≤–æ–¥–∏–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã
                        if (results.length > 0) {
                            const best = results[0];
                            document.getElementById('status').innerHTML = `
                                <span class="success">–ê–Ω–∞–ª–∏–∑ –∑–∞–≤–µ—Ä—à–µ–Ω –∑–∞ ${((endTime - startTime)/1000).toFixed(2)} —Å–µ–∫. –ü—Ä–æ–≤–µ—Ä–µ–Ω–æ ${results.length} –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤.</span>
                            `;
                            
                            // –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–π —Ç–µ–∫—Å—Ç —Å –≤—ã–¥–µ–ª–µ–Ω–∏–µ–º –∫–ª—é—á–∞
                            const formattedOriginal = formatOriginalText(originalText, best.key, preserveSpaces);
                            
                            document.getElementById('result').innerHTML = `
                                <div class="key-candidate">
                                    <p><strong>–õ—É—á—à–∏–π –∫–ª—é—á:</strong> <span class="highlight">${best.key}</span> (–¥–ª–∏–Ω–∞: ${best.key.length})</p>
                                    <p><strong>–û—Ü–µ–Ω–∫–∞:</strong> ${best.score.toFixed(2)}</p>
                                    <p><strong>–†–∞—Å—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã–π —Ç–µ–∫—Å—Ç:</strong></p>
                                    <div style="background: white; padding: 10px; border-radius: 4px; margin-top: 10px; word-break: break-all;">
                                        ${best.decrypted}
                                    </div>
                                    <p><strong>–ò—Å—Ö–æ–¥–Ω—ã–π —Ç–µ–∫—Å—Ç —Å –∫–ª—é—á–æ–º:</strong></p>
                                    <div style="background: white; padding: 10px; border-radius: 4px; margin-top: 10px; word-break: break-all; font-family: monospace;">
                                        ${formattedOriginal}
                                    </div>
                                </div>
                            `;
                            
                            // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –¥—Ä—É–≥–∏–µ –≤–∞—Ä–∏–∞–Ω—Ç—ã
                            if (results.length > 1) {
                                let candidatesHTML = '<h4>–î—Ä—É–≥–∏–µ –≤–æ–∑–º–æ–∂–Ω—ã–µ –∫–ª—é—á–∏:</h4><div class="key-grid">';
                                for (let i = 1; i < Math.min(maxResults, results.length); i++) {
                                    const r = results[i];
                                    candidatesHTML += `
                                        <div class="key-candidate key-info" onclick="showKeyDetails('${r.key}')">
                                            <p><strong>–ö–ª—é—á:</strong> ${r.key}</p>
                                            <p><strong>–î–ª–∏–Ω–∞:</strong> ${r.key.length}</p>
                                            <p><strong>–û—Ü–µ–Ω–∫–∞:</strong> ${r.score.toFixed(2)}</p>
                                            <p><strong>–¢–µ–∫—Å—Ç:</strong> ${r.decrypted.substring(0, 30)}${r.decrypted.length > 30 ? '...' : ''}</p>
                                        </div>
                                    `;
                                }
                                candidatesHTML += '</div>';
                                document.getElementById('candidates').innerHTML = candidatesHTML;
                            }
                        } else {
                            document.getElementById('status').innerHTML = '<span class="error">–ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏ –ø–æ–¥—Ö–æ–¥—è—â–∏–π –∫–ª—é—á</span>';
                        }
                        
                        // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –∞–Ω–∞–ª–∏–∑ –∫–ª—é—á–∞ –¥–ª—è –ª—É—á—à–µ–≥–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞
                        if (results.length > 0) {
                            showKeyAnalysis(results[0].key, ciphertext);
                        }
                    }).catch(e => {
                        if (!stopRequested) {
                            document.getElementById('status').innerHTML = `<span class="error">–û—à–∏–±–∫–∞: ${e.message}</span>`;
                            console.error(e);
                        }
                    }).finally(() => {
                        isAnalyzing = false;
                        document.getElementById('stopButton').disabled = true;
                    });
                    
                } catch (e) {
                    document.getElementById('status').innerHTML = `<span class="error">–û—à–∏–±–∫–∞: ${e.message}</span>`;
                    console.error(e);
                    isAnalyzing = false;
                    document.getElementById('stopButton').disabled = true;
                }
            }, 100);
        }
        
        // –û—Å—Ç–∞–Ω–æ–≤–∫–∞ –∞–Ω–∞–ª–∏–∑–∞
        function stopAnalysis() {
            if (isAnalyzing) {
                stopRequested = true;
                document.getElementById('status').innerHTML = '<span class="error">–ê–Ω–∞–ª–∏–∑ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º</span>';
            }
        }
        
        // –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ —Ç–µ–∫—Å—Ç–∞ (–æ—á–∏—Å—Ç–∫–∞ –∏ –ø—Ä–∏–≤–µ–¥–µ–Ω–∏–µ –∫ –≤–µ—Ä—Ö–Ω–µ–º—É —Ä–µ–≥–∏—Å—Ç—Ä—É)
        function prepareText(text, preserveCase, preserveSpaces) {
            let result = text;
            
            if (!preserveCase) {
                result = result.toUpperCase();
            }
            
            if (!preserveSpaces) {
                // –£–¥–∞–ª—è–µ–º –≤—Å–µ, –∫—Ä–æ–º–µ –±—É–∫–≤
                if (currentLanguage === 'english') {
                    result = result.replace(/[^A-Za-z]/g, '');
                } else {
                    result = result.replace(/[^–ê-–Ø–∞-—è–Å—ë]/g, '');
                }
            }
            
            return result;
        }
        
        // –§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω–æ–≥–æ —Ç–µ–∫—Å—Ç–∞ —Å –≤—ã–¥–µ–ª–µ–Ω–∏–µ–º –∫–ª—é—á–∞
        function formatOriginalText(text, key, preserveSpaces) {
            let result = '';
            let keyPos = 0;
            const keyLength = key.length;
            
            for (let i = 0; i < text.length; i++) {
                const char = text[i];
                let isLetter = false;
                
                if (currentLanguage === 'english') {
                    isLetter = /[A-Za-z]/.test(char);
                } else {
                    isLetter = /[–ê-–Ø–∞-—è–Å—ë]/.test(char);
                }
                
                if (isLetter) {
                    const keyChar = key[keyPos % keyLength];
                    result += `<span class="highlight" title="–°–∏–º–≤–æ–ª –∫–ª—é—á–∞: ${keyChar}">${char}</span>`;
                    keyPos++;
                } else if (preserveSpaces) {
                    result += char;
                }
            }
            
            return result;
        }
        
        // –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π –∞–Ω–∞–ª–∏–∑ —Å –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ–º –¥–ª–∏–Ω—ã –∫–ª—é—á–∞
        function autoAnalysis(ciphertext, minKeyLength, maxKeyLength, maxResults, qualityThreshold) {
            return new Promise((resolve) => {
                const candidates = findKeyCandidates(ciphertext, minKeyLength, maxKeyLength);
                
                if (stopRequested) return resolve([]);
                
                // –†–∞—Å—à–∏—Ñ—Ä–æ–≤—ã–≤–∞–µ–º —Å –ª—É—á—à–∏–º–∏ –∫–ª—é—á–∞–º–∏ –∏ –æ—Ü–µ–Ω–∏–≤–∞–µ–º
                const results = [];
                const totalKeys = candidates.length;
                let processed = 0;
                
                for (const candidate of candidates) {
                    if (stopRequested) return resolve([]);
                    
                    const decrypted = decryptVigenere(ciphertext, candidate.key);
                    const score = evaluateDecryption(decrypted);
                    
                    if (score >= qualityThreshold * 100) {
                        results.push({
                            key: candidate.key,
                            decrypted: decrypted,
                            score: score,
                            length: candidate.key.length
                        });
                    }
                    
                    processed++;
                    updateProgress(processed / totalKeys * 100);
                }
                
                // –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ –∫–∞—á–µ—Å—Ç–≤—É
                results.sort((a, b) => b.score - a.score);
                
                // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤
                resolve(results.slice(0, maxResults));
            });
        }
        
        // –ë—Ä—É—Ç—Ñ–æ—Ä—Å –≤—Å–µ—Ö –≤–æ–∑–º–æ–∂–Ω—ã—Ö –∫–ª—é—á–µ–π –∑–∞–¥–∞–Ω–Ω–æ–π –¥–ª–∏–Ω—ã
        function bruteForceAnalysis(ciphertext, minKeyLength, maxKeyLength, maxResults, qualityThreshold) {
            return new Promise((resolve) => {
                const results = [];
                const totalKeys = calculateTotalKeys(minKeyLength, maxKeyLength);
                let processed = 0;
                
                for (let len = minKeyLength; len <= maxKeyLength; len++) {
                    if (stopRequested) return resolve([]);
                    
                    // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –≤—Å–µ –≤–æ–∑–º–æ–∂–Ω—ã–µ –∫–ª—é—á–∏ –¥–∞–Ω–Ω–æ–π –¥–ª–∏–Ω—ã
                    const keys = generateAllKeys(len);
                    
                    for (const key of keys) {
                        if (stopRequested) return resolve([]);
                        
                        const decrypted = decryptVigenere(ciphertext, key);
                        const score = evaluateDecryption(decrypted);
                        
                        if (score >= qualityThreshold * 100) {
                            results.push({
                                key: key,
                                decrypted: decrypted,
                                score: score,
                                length: key.length
                            });
                        }
                        
                        processed++;
                        if (processed % 1000 === 0) {
                            updateProgress(processed / totalKeys * 100);
                        }
                    }
                }
                
                // –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ –∫–∞—á–µ—Å—Ç–≤—É
                results.sort((a, b) => b.score - a.score);
                
                // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤
                resolve(results.slice(0, maxResults));
            });
        }
        
        // –ê–Ω–∞–ª–∏–∑ –ø—Ä–∏ –∏–∑–≤–µ—Å—Ç–Ω–æ–π –¥–ª–∏–Ω–µ –∫–ª—é—á–∞
        function analyzeKnownLength(ciphertext, keyLength, maxResults) {
            return new Promise((resolve) => {
                const candidates = findKeyCandidates(ciphertext, keyLength, keyLength);
                
                if (stopRequested) return resolve([]);
                
                // –†–∞—Å—à–∏—Ñ—Ä–æ–≤—ã–≤–∞–µ–º —Å –ª—É—á—à–∏–º–∏ –∫–ª—é—á–∞–º–∏ –∏ –æ—Ü–µ–Ω–∏–≤–∞–µ–º
                const results = [];
                
                for (const candidate of candidates) {
                    if (stopRequested) return resolve([]);
                    
                    const decrypted = decryptVigenere(ciphertext, candidate.key);
                    const score = evaluateDecryption(decrypted);
                    
                    results.push({
                        key: candidate.key,
                        decrypted: decrypted,
                        score: score,
                        length: candidate.key.length
                    });
                }
                
                // –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ –∫–∞—á–µ—Å—Ç–≤—É
                results.sort((a, b) => b.score - a.score);
                
                // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤
                resolve(results.slice(0, maxResults));
            });
        }
        
        // –ü–æ–∏—Å–∫ –∫–∞–Ω–¥–∏–¥–∞—Ç–æ–≤ –Ω–∞ –∫–ª—é—á —Å –ø–æ–º–æ—â—å—é —á–∞—Å—Ç–æ—Ç–Ω–æ–≥–æ –∞–Ω–∞–ª–∏–∑–∞
        function findKeyCandidates(ciphertext, minKeyLength, maxKeyLength) {
            const candidates = [];
            
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤—Å–µ –≤–æ–∑–º–æ–∂–Ω—ã–µ –¥–ª–∏–Ω—ã –∫–ª—é—á–∞
            for (let keyLen = minKeyLength; keyLen <= maxKeyLength; keyLen++) {
                if (stopRequested) return candidates;
                
                const groups = Array(keyLen).fill().map(() => []);
                
                // –†–∞–∑–¥–µ–ª—è–µ–º —Ç–µ–∫—Å—Ç –Ω–∞ –≥—Ä—É–ø–ø—ã
                for (let i = 0; i < ciphertext.length; i++) {
                    groups[i % keyLen].push(ciphertext[i]);
                }
                
                // –î–ª—è –∫–∞–∂–¥–æ–π –≥—Ä—É–ø–ø—ã –Ω–∞—Ö–æ–¥–∏–º –Ω–∞–∏–±–æ–ª–µ–µ –≤–µ—Ä–æ—è—Ç–Ω—ã–π —Å–¥–≤–∏–≥
                let key = '';
                for (const group of groups) {
                    const freqs = calculateFrequencies(group);
                    const bestShift = findBestShift(freqs);
                    key += String.fromCharCode(bestShift + (currentLanguage === 'english' ? 65 : 1040)); // A –∏–ª–∏ –ê
                }
                
                // –î–æ–±–∞–≤–ª—è–µ–º –∫–∞–Ω–¥–∏–¥–∞—Ç–∞
                candidates.push({
                    key: key,
                    length: keyLen
                });
                
                updateProgress(keyLen / maxKeyLength * 50); // –ü–µ—Ä–≤–∞—è –ø–æ–ª–æ–≤–∏–Ω–∞ –ø—Ä–æ–≥—Ä–µ—Å—Å–∞
            }
            
            return candidates;
        }
        
        // –†–∞—Å—á–µ—Ç –æ–±—â–µ–≥–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –∫–ª—é—á–µ–π –¥–ª—è –±—Ä—É—Ç—Ñ–æ—Ä—Å–∞
        function calculateTotalKeys(minKeyLength, maxKeyLength) {
            let total = 0;
            const alphabetSize = currentLanguage === 'english' ? 26 : 33;
            
            for (let len = minKeyLength; len <= maxKeyLength; len++) {
                total += Math.pow(alphabetSize, len);
            }
            
            return total;
        }
        
        // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –≤—Å–µ—Ö –≤–æ–∑–º–æ–∂–Ω—ã—Ö –∫–ª—é—á–µ–π –∑–∞–¥–∞–Ω–Ω–æ–π –¥–ª–∏–Ω—ã
        function generateAllKeys(length) {
            const keys = [];
            const alphabetSize = currentLanguage === 'english' ? 26 : 33;
            const firstCharCode = currentLanguage === 'english' ? 65 : 1040; // A –∏–ª–∏ –ê
            
            // –†–µ–∫—É—Ä—Å–∏–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∫–ª—é—á–µ–π
            function generate(current) {
                if (current.length === length) {
                    keys.push(current);
                    return;
                }
                
                for (let i = 0; i < alphabetSize; i++) {
                    if (stopRequested) return;
                    generate(current + String.fromCharCode(firstCharCode + i));
                }
            }
            
            generate('');
            return keys;
        }
        
        // –†–∞—Å—á–µ—Ç —á–∞—Å—Ç–æ—Ç —Å–∏–º–≤–æ–ª–æ–≤ –≤ —Ç–µ–∫—Å—Ç–µ
        function calculateFrequencies(text) {
            const freqs = {};
            let total = 0;
            
            for (const c of text) {
                const upperC = c.toUpperCase();
                if ((currentLanguage === 'english' && /[A-Z]/.test(upperC)) || 
                    (currentLanguage === 'russian' && /[–ê-–Ø–Å]/.test(upperC))) {
                    freqs[upperC] = (freqs[upperC] || 0) + 1;
                    total++;
                }
            }
            
            // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –≤ –ø—Ä–æ—Ü–µ–Ω—Ç—ã
            for (const c in freqs) {
                freqs[c] = (freqs[c] / total) * 100;
            }
            
            return freqs;
        }
        
        // –ü–æ–∏—Å–∫ –Ω–∞–∏–ª—É—á—à–µ–≥–æ —Å–¥–≤–∏–≥–∞ –¥–ª—è –≥—Ä—É–ø–ø—ã —Å–∏–º–≤–æ–ª–æ–≤
        function findBestShift(freqs) {
            let bestShift = 0;
            let bestScore = -Infinity;
            const alphabetSize = currentLanguage === 'english' ? 26 : 33;
            
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤—Å–µ –≤–æ–∑–º–æ–∂–Ω—ã–µ —Å–¥–≤–∏–≥–∏
            for (let shift = 0; shift < alphabetSize; shift++) {
                let score = 0;
                
                // –°—á–∏—Ç–∞–µ–º –æ—Ü–µ–Ω–∫—É –¥–ª—è –∫–∞–∂–¥–æ–≥–æ —Å–¥–≤–∏–≥–∞
                for (const c in freqs) {
                    let decryptedChar;
                    if (currentLanguage === 'english') {
                        decryptedChar = String.fromCharCode(
                            ((c.charCodeAt(0) - 65 - shift + 26) % 26) + 65
                        );
                    } else {
                        // –î–ª—è —Ä—É—Å—Å–∫–æ–≥–æ —è–∑—ã–∫–∞ —É—á–∏—Ç—ã–≤–∞–µ–º –Å
                        const code = c.charCodeAt(0);
                        let index;
                        
                        if (code >= 1040 && code <= 1045) index = code - 1040;
                        else if (code === 1025) index = 6; // –Å
                        else if (code >= 1046 && code <= 1071) index = code - 1040 + 1; // +1 –∏–∑-–∑–∞ –Å
                        else continue;
                        
                        decryptedChar = String.fromCharCode(
                            ((index - shift + alphabetSize) % alphabetSize) + 1040
                        );
                        
                        // –ö–æ—Ä—Ä–µ–∫—Ç–∏—Ä–æ–≤–∫–∞ –¥–ª—è –Å
                        if (decryptedChar === String.fromCharCode(1046)) decryptedChar = '–Å';
                    }
                    
                    score += (currentFrequencies.frequencies[decryptedChar] || 0) * freqs[c];
                }
                
                if (score > bestScore) {
                    bestScore = score;
                    bestShift = shift;
                }
            }
            
            return bestShift;
        }
        
        // –î–µ—à–∏—Ñ—Ä–æ–≤–∫–∞ —Ç–µ–∫—Å—Ç–∞ –í–∏–∂–µ–Ω–µ—Ä–∞
        function decryptVigenere(ciphertext, key) {
            let decrypted = '';
            const keyLen = key.length;
            const alphabetSize = currentLanguage === 'english' ? 26 : 33;
            const firstCharCode = currentLanguage === 'english' ? 65 : 1040; // A –∏–ª–∏ –ê
            
            for (let i = 0; i < ciphertext.length; i++) {
                const cipherChar = ciphertext[i];
                let upperC = cipherChar.toUpperCase();
                
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —Å–∏–º–≤–æ–ª –±—É–∫–≤–æ–π –Ω—É–∂–Ω–æ–≥–æ –∞–ª—Ñ–∞–≤–∏—Ç–∞
                if ((currentLanguage === 'english' && /[A-Z]/.test(upperC)) || 
                    (currentLanguage === 'russian' && /[–ê-–Ø–Å]/.test(upperC))) {
                    
                    // –ü–æ–ª—É—á–∞–µ–º –∫–æ–¥ —Å–∏–º–≤–æ–ª–∞ —Å —É—á–µ—Ç–æ–º —è–∑—ã–∫–∞
                    let cipherCode, keyCode;
                    
                    if (currentLanguage === 'english') {
                        cipherCode = upperC.charCodeAt(0) - 65;
                        keyCode = key[i % keyLen].toUpperCase().charCodeAt(0) - 65;
                    } else {
                        // –î–ª—è —Ä—É—Å—Å–∫–æ–≥–æ —è–∑—ã–∫–∞ —É—á–∏—Ç—ã–≤–∞–µ–º –Å
                        cipherCode = upperC === '–Å' ? 6 : 
                                    (upperC.charCodeAt(0) >= 1046 ? upperC.charCodeAt(0) - 1040 + 1 : 
                                    upperC.charCodeAt(0) - 1040);
                                    
                        const keyChar = key[i % keyLen].toUpperCase();
                        keyCode = keyChar === '–Å' ? 6 : 
                                 (keyChar.charCodeAt(0) >= 1046 ? keyChar.charCodeAt(0) - 1040 + 1 : 
                                 keyChar.charCodeAt(0) - 1040);
                    }
                    
                    const decryptedCode = (cipherCode - keyCode + alphabetSize) % alphabetSize;
                    let decryptedChar;
                    
                    if (currentLanguage === 'english') {
                        decryptedChar = String.fromCharCode(decryptedCode + 65);
                    } else {
                        // –î–ª—è —Ä—É—Å—Å–∫–æ–≥–æ –æ–±—Ä–∞—Ç–Ω–∞—è –∫–æ—Ä—Ä–µ–∫—Ç–∏—Ä–æ–≤–∫–∞
                        decryptedChar = decryptedCode === 6 ? '–Å' : 
                                       (decryptedCode >= 7 ? String.fromCharCode(decryptedCode + 1040 - 1) : 
                                       String.fromCharCode(decryptedCode + 1040));
                    }
                    
                    // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ä–µ–≥–∏—Å—Ç—Ä
                    if (/[a-z]/.test(cipherChar) && document.getElementById('preserveCase').checked) {
                        decrypted += decryptedChar.toLowerCase();
                    } else {
                        decrypted += decryptedChar;
                    }
                } else if (document.getElementById('preserveSpaces').checked) {
                    // –°–æ—Ö—Ä–∞–Ω—è–µ–º –Ω–µ-–±—É–∫–≤–µ–Ω–Ω—ã–µ —Å–∏–º–≤–æ–ª—ã, –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
                    decrypted += cipherChar;
                }
            }
            
            return decrypted;
        }
        
        // –û—Ü–µ–Ω–∫–∞ –∫–∞—á–µ—Å—Ç–≤–∞ —Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ —Ç–µ–∫—Å—Ç–∞
        function evaluateDecryption(text) {
            let score = 0;
            
            // 1. –ß–∞—Å—Ç–æ—Ç–Ω–æ—Å—Ç—å –±—É–∫–≤
            const textFreq = calculateFrequencies(text);
            for (const c in textFreq) {
                score += (currentFrequencies.frequencies[c] || 0) * textFreq[c] / 100;
            }
            
            // 2. –ü—Ä–æ–≤–µ—Ä–∫–∞ –±–∏–≥—Ä–∞–º–º
            for (let i = 0; i < text.length - 1; i++) {
                const bigram = text.substr(i, 2).toUpperCase();
                if (currentFrequencies.commonBigrams.includes(bigram)) {
                    score += 5;
                }
            }
            
            // 3. –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ç—Ä–∏–≥—Ä–∞–º–º
            for (let i = 0; i < text.length - 2; i++) {
                const trigram = text.substr(i, 3).toUpperCase();
                if (currentFrequencies.commonTrigrams.includes(trigram)) {
                    score += 15;
                }
            }
            
            // 4. –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–ª–æ–≤
            for (const word of currentFrequencies.commonWords) {
                const regex = new RegExp(word, 'gi');
                const matches = text.match(regex);
                if (matches) {
                    score += 20 * word.length * matches.length;
                }
            }
            
            // 5. –®—Ç—Ä–∞—Ñ –∑–∞ —Ä–µ–¥–∫–∏–µ –±—É–∫–≤—ã
            const rareLetters = currentLanguage === 'english' ? 
                ['Z', 'Q', 'X', 'J', 'K'] : 
                ['–§', '–¶', '–©', '–≠', '–™'];
                
            for (const c of rareLetters) {
                const regex = new RegExp(c, 'g');
                const matches = text.toUpperCase().match(regex);
                if (matches) {
                    score -= 5 * matches.length;
                }
            }
            
            // 6. –ë–æ–Ω—É—Å –∑–∞ –ø—Ä–æ–±–µ–ª—ã (–µ—Å–ª–∏ –æ–Ω–∏ –µ—Å—Ç—å –∏ –≤—ã–≥–ª—è–¥—è—Ç –æ—Å–º—ã—Å–ª–µ–Ω–Ω–æ)
            if (/\s/.test(text)) {
                const words = text.split(/\s+/).filter(w => w.length > 0);
                if (words.length > 3) {
                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ —Å—Ä–µ–¥–∏ —Å–ª–æ–≤ —á–∞—Å—Ç—ã–µ —Å–ª–æ–≤–∞
                    let commonWordsCount = 0;
                    for (const word of words) {
                        if (currentFrequencies.commonWords.includes(word.toUpperCase())) {
                            commonWordsCount++;
                        }
                    }
                    
                    if (commonWordsCount > 0) {
                        score += 50 * commonWordsCount;
                    }
                }
            }
            
            return score;
        }
        
        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–∞ –ø—Ä–æ–≥—Ä–µ—Å—Å–∞
        function updateProgress(percent) {
            const progressBar = document.getElementById('progressBar');
            const rounded = Math.round(percent);
            progressBar.style.width = `${rounded}%`;
            progressBar.textContent = `${rounded}%`;
        }
        
        // –ê–Ω–∞–ª–∏–∑ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ —Ç–µ–∫—Å—Ç–∞
        function analyzeTextStats(text) {
            const statsDiv = document.getElementById('textStats');
            const freqs = calculateFrequencies(text);
            const totalLetters = Object.values(freqs).reduce((a, b) => a + b, 0) / 100;
            
            // –°–æ—Ä—Ç–∏—Ä—É–µ–º –±—É–∫–≤—ã –ø–æ —á–∞—Å—Ç–æ—Ç–µ
            const sortedFreqs = Object.entries(freqs).sort((a, b) => b[1] - a[1]);
            
            let html = `
                <p><strong>–û–±—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –±—É–∫–≤:</strong> ${Math.round(totalLetters)}</p>
                <h4>–ß–∞—Å—Ç–æ—Ç–Ω–æ—Å—Ç—å –±—É–∫–≤:</h4>
                <table class="stats-table">
                    <tr>
                        <th>–ë—É–∫–≤–∞</th>
                        <th>–ß–∞—Å—Ç–æ—Ç–∞</th>
                        <th>–û–∂–∏–¥–∞–µ–º–∞—è</th>
                        <th>–û—Ç–∫–ª–æ–Ω–µ–Ω–∏–µ</th>
                    </tr>
            `;
            
            for (const [char, freq] of sortedFreqs) {
                const expected = currentFrequencies.frequencies[char] || 0;
                const deviation = freq - expected;
                const deviationColor = deviation > 0 ? '#e74c3c' : '#27ae60';
                
                html += `
                    <tr>
                        <td>${char}</td>
                        <td>${freq.toFixed(2)}%</td>
                        <td>${expected.toFixed(2)}%</td>
                        <td style="color: ${deviationColor}">${deviation > 0 ? '+' : ''}${deviation.toFixed(2)}%</td>
                    </tr>
                `;
            }
            
            html += `</table>`;
            
            // –ê–Ω–∞–ª–∏–∑ –∏–Ω–¥–µ–∫—Å–∞ —Å–æ–≤–ø–∞–¥–µ–Ω–∏–π
            const ic = calculateIndexOfCoincidence(text);
            const expectedIc = currentLanguage === 'english' ? 0.0667 : 0.0553;
            
            html += `
                <div class="analysis-section">
                    <h4>–ò–Ω–¥–µ–∫—Å —Å–æ–≤–ø–∞–¥–µ–Ω–∏–π (IC):</h4>
                    <p>–†–∞—Å—Å—á–∏—Ç–∞–Ω–Ω—ã–π: ${ic.toFixed(5)}</p>
                    <p>–û–∂–∏–¥–∞–µ–º—ã–π –¥–ª—è ${currentFrequencies.name}: ${expectedIc.toFixed(5)}</p>
                    <p>–ò–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ü–∏—è: ${interpretIC(ic, expectedIc)}</p>
                </div>
            `;
            
            statsDiv.innerHTML = html;
        }
        
        // –†–∞—Å—á–µ—Ç –∏–Ω–¥–µ–∫—Å–∞ —Å–æ–≤–ø–∞–¥–µ–Ω–∏–π
        function calculateIndexOfCoincidence(text) {
            const freqs = {};
            let total = 0;
            
            for (const c of text) {
                const upperC = c.toUpperCase();
                if ((currentLanguage === 'english' && /[A-Z]/.test(upperC)) || 
                    (currentLanguage === 'russian' && /[–ê-–Ø–Å]/.test(upperC))) {
                    freqs[upperC] = (freqs[upperC] || 0) + 1;
                    total++;
                }
            }
            
            if (total < 2) return 0;
            
            let sum = 0;
            const alphabetSize = currentLanguage === 'english' ? 26 : 33;
            
            for (const c in freqs) {
                sum += freqs[c] * (freqs[c] - 1);
            }
            
            return sum / (total * (total - 1));
        }
        
        // –ò–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ü–∏—è –∏–Ω–¥–µ–∫—Å–∞ —Å–æ–≤–ø–∞–¥–µ–Ω–∏–π
        function interpretIC(ic, expectedIc) {
            const ratio = ic / expectedIc;
            
            if (ratio > 0.9 && ratio < 1.1) {
                return "–¢–µ–∫—Å—Ç, –≤–µ—Ä–æ—è—Ç–Ω–æ, –Ω–µ –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω –∏–ª–∏ –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω –º–æ–Ω–æ–∞–ª—Ñ–∞–≤–∏—Ç–Ω—ã–º —à–∏—Ñ—Ä–æ–º";
            } else if (ic < 0.038) {
                return "–í–æ–∑–º–æ–∂–Ω–æ, –ø–æ–ª–∏–∞–ª—Ñ–∞–≤–∏—Ç–Ω–æ–µ —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ —Å –¥–ª–∏–Ω–Ω—ã–º –∫–ª—é—á–æ–º";
            } else {
                return "–í–æ–∑–º–æ–∂–Ω–æ, —à–∏—Ñ—Ä –í–∏–∂–µ–Ω–µ—Ä–∞ –∏–ª–∏ –¥—Ä—É–≥–æ–π –ø–æ–ª–∏–∞–ª—Ñ–∞–≤–∏—Ç–Ω—ã–π —à–∏—Ñ—Ä";
            }
        }
        
        // –ü–æ–∫–∞–∑ –¥–µ—Ç–∞–ª–µ–π –∞–Ω–∞–ª–∏–∑–∞ –¥–ª—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ –∫–ª—é—á–∞
        function showKeyDetails(key) {
            const ciphertext = prepareText(
                document.getElementById('ciphertext').value,
                document.getElementById('preserveCase').checked,
                document.getElementById('preserveSpaces').checked
            );
            
            showKeyAnalysis(key, ciphertext);
            switchTab('analysis');
            
            // –ü–æ–¥—Å–≤–µ—á–∏–≤–∞–µ–º –≤—ã–±—Ä–∞–Ω–Ω—ã–π –∫–ª—é—á
            document.querySelectorAll('.key-info').forEach(el => {
                el.classList.remove('highlight');
            });
            
            event.currentTarget.classList.add('highlight');
        }
        
        // –ê–Ω–∞–ª–∏–∑ –∫–ª—é—á–∞
        function showKeyAnalysis(key, ciphertext) {
            const keyAnalysisDiv = document.getElementById('keyAnalysis');
            const decrypted = decryptVigenere(ciphertext, key);
            const keyLength = key.length;
            
            // –†–∞–∑–±–∏–≤–∞–µ–º —Ç–µ–∫—Å—Ç –Ω–∞ –≥—Ä—É–ø–ø—ã –ø–æ –∫–ª—é—á—É
            const groups = Array(keyLength).fill().map(() => []);
            for (let i = 0; i < ciphertext.length; i++) {
                groups[i % keyLength].push(ciphertext[i]);
            }
            
            let html = `
                <div class="key-candidate">
                    <p><strong>–ê–Ω–∞–ª–∏–∑ –∫–ª—é—á–∞:</strong> ${key} (–¥–ª–∏–Ω–∞: ${keyLength})</p>
                    <p><strong>–†–∞—Å—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã–π —Ç–µ–∫—Å—Ç:</strong> ${decrypted.substring(0, 100)}${decrypted.length > 100 ? '...' : ''}</p>
                </div>
                
                <div class="analysis-section">
                    <h4>–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ –ø–æ–∑–∏—Ü–∏—è–º –∫–ª—é—á–∞:</h4>
                    <table class="stats-table">
                        <tr>
                            <th>–ü–æ–∑–∏—Ü–∏—è</th>
                            <th>–°–∏–º–≤–æ–ª –∫–ª—é—á–∞</th>
                            <th>–ö–æ–ª-–≤–æ —Å–∏–º–≤–æ–ª–æ–≤</th>
                            <th>–¢–æ–ø-3 —Å–∏–º–≤–æ–ª–∞</th>
                            <th>–ü—Ä–µ–¥–ø–æ–ª–∞–≥–∞–µ–º—ã–π —Å–¥–≤–∏–≥</th>
                        </tr>
            `;
            
            for (let i = 0; i < keyLength; i++) {
                const group = groups[i];
                const freqs = calculateFrequencies(group);
                const sortedFreqs = Object.entries(freqs).sort((a, b) => b[1] - a[1]);
                
                const topChars = sortedFreqs.slice(0, 3).map(([char, freq]) => 
                    `${char}: ${freq.toFixed(1)}%`).join(', ');
                
                // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –ø—Ä–µ–¥–ø–æ–ª–∞–≥–∞–µ–º—ã–π —Å–¥–≤–∏–≥
                const bestShift = findBestShift(freqs);
                const shiftChar = String.fromCharCode(
                    bestShift + (currentLanguage === 'english' ? 65 : 1040)
                );
                
                html += `
                    <tr>
                        <td>${i + 1}</td>
                        <td>${key[i]}</td>
                        <td>${group.length}</td>
                        <td>${topChars}</td>
                        <td>${bestShift} (${shiftChar})</td>
                    </tr>
                `;
            }
            
            html += `
                    </table>
                </div>
                
                <div class="analysis-section">
                    <h4>–ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–ª–æ–≤ –≤ —Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω–æ–º —Ç–µ–∫—Å—Ç–µ:</h4>
            `;
            
            // –ò—â–µ–º –∏–∑–≤–µ—Å—Ç–Ω—ã–µ —Å–ª–æ–≤–∞ –≤ —Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω–æ–º —Ç–µ–∫—Å—Ç–µ
            const foundWords = [];
            const upperDecrypted = decrypted.toUpperCase();
            
            for (const word of currentFrequencies.commonWords) {
                if (upperDecrypted.includes(word)) {
                    foundWords.push(word);
                }
            }
            
            if (foundWords.length > 0) {
                html += `<p>–ù–∞–π–¥–µ–Ω—ã —Å–ª–æ–≤–∞: ${foundWords.join(', ')}</p>`;
            } else {
                html += `<p>–ù–µ –Ω–∞–π–¥–µ–Ω–æ –Ω–∏ –æ–¥–Ω–æ–≥–æ –∏–∑ ${currentFrequencies.commonWords.length} —Ä–∞—Å–ø—Ä–æ—Å—Ç—Ä–∞–Ω–µ–Ω–Ω—ã—Ö —Å–ª–æ–≤</p>`;
            }
            
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º –±–∏–≥—Ä–∞–º–º—ã
            const foundBigrams = [];
            for (let i = 0; i < upperDecrypted.length - 1; i++) {
                const bigram = upperDecrypted.substr(i, 2);
                if (currentFrequencies.commonBigrams.includes(bigram) && !foundBigrams.includes(bigram)) {
                    foundBigrams.push(bigram);
                }
            }
            
            html += `<p>–ù–∞–π–¥–µ–Ω—ã –±–∏–≥—Ä–∞–º–º—ã: ${foundBigrams.length > 0 ? foundBigrams.join(', ') : '–Ω–µ—Ç'}</p>`;
            
            html += `</div>`;
            
            keyAnalysisDiv.innerHTML = html;
        }
        
        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ
        window.onload = function() {
            updateKeyLength();
            updateMinKeyLength();
            updateQualityThreshold();
        };
    </script>
</body>
</html>
